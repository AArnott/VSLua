// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ImmutableTree Version: 0.0.0.1
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

namespace LanguageModel {
	using System.Diagnostics;
	using System.Linq;
	using ImmutableObjectGraph;
	
	public abstract partial class SyntaxNode : IRecursiveType, IRecursiveDiffingType<SyntaxNodeChangedProperties, SyntaxNode.DiffGram> {
		
		/// <summary>The last identity assigned to a created instance.</summary>
		private static int lastIdentityProduced;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.Collections.Immutable.ImmutableList<Trivia> triviaList;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.Int32 fullStartPosition;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.Int32 startPosition;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.Int32 length;
	
		private readonly System.UInt32 identity;
	
		/// <summary>Initializes a new instance of the SyntaxNode class.</summary>
		protected SyntaxNode(
			System.UInt32 identity,
			System.Collections.Immutable.ImmutableList<Trivia> triviaList,
			System.Int32 fullStartPosition,
			System.Int32 startPosition,
			System.Int32 length,
			ImmutableObjectGraph.Optional<bool> skipValidation = default(ImmutableObjectGraph.Optional<bool>))
		{
			this.identity = identity;
			this.triviaList = triviaList;
			this.fullStartPosition = fullStartPosition;
			this.startPosition = startPosition;
			this.length = length;
		}
	
		public System.Collections.Immutable.ImmutableList<Trivia> TriviaList {
			get { return this.triviaList; }
		}
	
		public System.Int32 FullStartPosition {
			get { return this.fullStartPosition; }
		}
	
		public System.Int32 StartPosition {
			get { return this.startPosition; }
		}
	
		public System.Int32 Length {
			get { return this.length; }
		}
		
		/// <summary>Replaces the elements of the TriviaList collection with the specified collection.</summary>
		public SyntaxNode WithTriviaList(params Trivia[] values) {
			return this.With(triviaList: this.TriviaList.ResetContents(values));
		}
		
		/// <summary>Replaces the elements of the TriviaList collection with the specified collection.</summary>
		public SyntaxNode WithTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return this.With(triviaList: this.TriviaList.ResetContents(values));
		}
		
		/// <summary>Adds the specified elements from the TriviaList collection.</summary>
		public SyntaxNode AddTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return this.With(triviaList: this.TriviaList.AddRange(values));
		}
		
		/// <summary>Adds the specified elements from the TriviaList collection.</summary>
		public SyntaxNode AddTriviaList(params Trivia[] values) {
			return this.With(triviaList: this.TriviaList.AddRange(values));
		}
		
		/// <summary>Adds the specified element from the TriviaList collection.</summary>
		public SyntaxNode AddTriviaList(Trivia value) {
			return this.With(triviaList: this.TriviaList.Add(value));
		}
		
		/// <summary>Removes the specified elements from the TriviaList collection.</summary>
		public SyntaxNode RemoveTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return this.With(triviaList: this.TriviaList.RemoveRange(values));
		}
		
		/// <summary>Removes the specified elements from the TriviaList collection.</summary>
		public SyntaxNode RemoveTriviaList(params Trivia[] values) {
			return this.With(triviaList: this.TriviaList.RemoveRange(values));
		}
		
		/// <summary>Removes the specified element from the TriviaList collection.</summary>
		public SyntaxNode RemoveTriviaList(Trivia value) {
			return this.With(triviaList: this.TriviaList.Remove(value));
		}
		
		/// <summary>Clears all elements from the TriviaList collection.</summary>
		public SyntaxNode RemoveTriviaList() {
			return this.With(triviaList: this.TriviaList.Clear());
		}
		
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public SyntaxNode With(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>)) {
			return (SyntaxNode)this.WithCore(
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected abstract SyntaxNode WithCore(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>));
	
		protected internal uint Identity {
			get { return (uint)this.identity; }
		}
	
		/// <summary>Returns a unique identity that may be assigned to a newly created instance.</summary>
		protected static System.UInt32 NewIdentity() {
			return (System.UInt32)System.Threading.Interlocked.Increment(ref lastIdentityProduced);
		}
		
		/// <summary>
		/// A description of a change made to an instance of an immutable object.
		/// </summary>
		[DebuggerDisplay("{Kind} {(Before ?? After).Caption} ({Identity}) {Changes}")]
		public struct DiffGram {
			private DiffGram(SyntaxNode before, SyntaxNode after, ChangeKind kind, SyntaxNodeChangedProperties changes)
				: this() {
				this.Before = before;
				this.After = after;
				this.Kind = kind;
				this.Changes = changes;
			}
		
			public static DiffGram Change(SyntaxNode before, SyntaxNode after, SyntaxNodeChangedProperties changes) {
				return new DiffGram(before, after, ChangeKind.Replaced, changes);
			}
		
			public static DiffGram Add(SyntaxNode value) {
				return new DiffGram(null, value, ChangeKind.Added, default(SyntaxNodeChangedProperties));
			}
		
			public static DiffGram Remove(SyntaxNode value) {
				return new DiffGram(value, null, ChangeKind.Removed, default(SyntaxNodeChangedProperties));
			}
		
			/// <summary>
			/// Gets the leaf node before the change.
			/// </summary>
			public SyntaxNode Before { get; private set; }
		
			/// <summary>
			/// Gets the leaf node after the change.
			/// </summary>
			public SyntaxNode After { get; private set; }
		
			/// <summary>
			/// Gets the kind of change made to the alterered node.
			/// </summary>
			public ChangeKind Kind { get; private set; }
		
			/// <summary>
			/// Gets the kinds of changes made to node if <see cref="Kind"/> is <see cref="ChangeKind.Replaced"/>.
			/// </summary>
			public SyntaxNodeChangedProperties Changes { get; private set; }
		
			/// <summary>
			/// Gets a value indicating whether the <see cref="SyntaxNode.TriviaList" /> was changed.
			/// </summary>
			public bool IsTriviaListChanged {
				get { return (this.Changes & SyntaxNodeChangedProperties.TriviaList) != SyntaxNodeChangedProperties.None; }
			}
		
			/// <summary>
			/// Gets a value indicating whether the <see cref="SyntaxNode.FullStartPosition" /> was changed.
			/// </summary>
			public bool IsFullStartPositionChanged {
				get { return (this.Changes & SyntaxNodeChangedProperties.FullStartPosition) != SyntaxNodeChangedProperties.None; }
			}
		
			/// <summary>
			/// Gets a value indicating whether the <see cref="SyntaxNode.StartPosition" /> was changed.
			/// </summary>
			public bool IsStartPositionChanged {
				get { return (this.Changes & SyntaxNodeChangedProperties.StartPosition) != SyntaxNodeChangedProperties.None; }
			}
		
			/// <summary>
			/// Gets a value indicating whether the <see cref="SyntaxNode.Length" /> was changed.
			/// </summary>
			public bool IsLengthChanged {
				get { return (this.Changes & SyntaxNodeChangedProperties.Length) != SyntaxNodeChangedProperties.None; }
			}
		
			/// <summary>
			/// Gets the identity of the affected object.
			/// </summary>
			public System.UInt32 Identity {
				get { return (this.Before ?? this.After).Identity; }
			}
		}
		
		public static class Comparers {
			/// <summary>Gets an equatable comparer that considers only the persistent identity of a pair of values.</summary>
			public static System.Collections.Generic.IEqualityComparer<SyntaxNode> Identity {
				get { return ImmutableObjectGraph.Comparers.Identity; }
			}
		
			/// <summary>Gets an equatable comparer that compares all properties between two instances.</summary>
			public static System.Collections.Generic.IEqualityComparer<SyntaxNode> ByValue {
				get { return ImmutableObjectGraph.Comparers.ByValue<SyntaxNodeChangedProperties, DiffGram>(deep: false); }
			}
		
			/// <summary>Gets an equatable comparer that considers all properties between two instances and their children.</summary>
			public static System.Collections.Generic.IEqualityComparer<SyntaxNode> ByValueWithDescendents {
				get { return ImmutableObjectGraph.Comparers.ByValue<SyntaxNodeChangedProperties, DiffGram>(deep: true); }
			}
		
			internal static System.Collections.Generic.IEqualityComparer<ParentedRecursiveType<Block, SyntaxNode>> ParentedSyntaxNodeIdentity {
				get { return ImmutableObjectGraph.Comparers.Parented<Block, SyntaxNode>(); }
			}
		}
		
		SyntaxNodeChangedProperties IRecursiveDiffingType<SyntaxNodeChangedProperties, SyntaxNode.DiffGram>.ParentProperty {
			get { return SyntaxNodeChangedProperties.Parent; }
		}
		
		SyntaxNodeChangedProperties IRecursiveDiffingType<SyntaxNodeChangedProperties, SyntaxNode.DiffGram>.PositionUnderParentProperty {
			get { return SyntaxNodeChangedProperties.PositionUnderParent; }
		}
		
		SyntaxNodeChangedProperties IRecursiveDiffingType<SyntaxNodeChangedProperties, SyntaxNode.DiffGram>.DiffProperties(IRecursiveType other) {
			return this.DiffProperties((SyntaxNode)other);
		}
		
		SyntaxNode.DiffGram IRecursiveDiffingType<SyntaxNodeChangedProperties, SyntaxNode.DiffGram>.Change(IRecursiveType before, IRecursiveType after, SyntaxNodeChangedProperties diff) {
			return DiffGram.Change((SyntaxNode)before, (SyntaxNode)after, diff);
		}
		
		SyntaxNode.DiffGram IRecursiveDiffingType<SyntaxNodeChangedProperties, SyntaxNode.DiffGram>.Add(IRecursiveType after) {
			return DiffGram.Add((SyntaxNode)after);
		}
		
		SyntaxNode.DiffGram IRecursiveDiffingType<SyntaxNodeChangedProperties, SyntaxNode.DiffGram>.Remove(IRecursiveType before) {
			return DiffGram.Remove((SyntaxNode)before);
		}
		
		bool IRecursiveDiffingType<SyntaxNodeChangedProperties, SyntaxNode.DiffGram>.Equals(SyntaxNodeChangedProperties first, SyntaxNodeChangedProperties second) {
			return first == second;
		}
		
		SyntaxNodeChangedProperties IRecursiveDiffingType<SyntaxNodeChangedProperties, SyntaxNode.DiffGram>.Union(SyntaxNodeChangedProperties first, SyntaxNodeChangedProperties second) {
			return first | second;
		}
		
		protected virtual SyntaxNodeChangedProperties DiffProperties(SyntaxNode other) {
			if (other == null) {
				throw new System.ArgumentNullException("other");
			}
		
			var propertiesChanged = SyntaxNodeChangedProperties.None;
		
			if (this != other) {
				if (!this.GetType().IsEquivalentTo(other.GetType())) {
					propertiesChanged |= SyntaxNodeChangedProperties.Type;
				}
		
				if (this.TriviaList != other.TriviaList) {
					propertiesChanged |= SyntaxNodeChangedProperties.TriviaList;
				}
		
				if (this.FullStartPosition != other.FullStartPosition) {
					propertiesChanged |= SyntaxNodeChangedProperties.FullStartPosition;
				}
		
				if (this.StartPosition != other.StartPosition) {
					propertiesChanged |= SyntaxNodeChangedProperties.StartPosition;
				}
		
				if (this.Length != other.Length) {
					propertiesChanged |= SyntaxNodeChangedProperties.Length;
				}
			}
		
			return propertiesChanged;
		}
		
		public virtual Block ToBlock(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<SyntaxNode>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<SyntaxNode>>)) {
			Block that = this as Block;
			if (that != null && this.GetType().IsEquivalentTo(typeof(Block))) {
				if ((!children.IsDefined || children.Value == that.Children)) {
					return that;
				}
			}
		
			return Block.CreateWithIdentity(
				triviaList: this.TriviaList,
				fullStartPosition: this.FullStartPosition,
				startPosition: this.StartPosition,
				length: this.Length,
				identity: this.Identity,
				children: children);
		}
		
		public virtual ElseBlock ToElseBlock(
			ImmutableObjectGraph.Optional<Keyword> elseKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Block> block = default(ImmutableObjectGraph.Optional<Block>)) {
			ElseBlock that = this as ElseBlock;
			if (that != null && this.GetType().IsEquivalentTo(typeof(ElseBlock))) {
				if ((!elseKeyword.IsDefined || elseKeyword.Value == that.ElseKeyword) && 
				    (!block.IsDefined || block.Value == that.Block)) {
					return that;
				}
			}
		
			return ElseBlock.CreateWithIdentity(
				triviaList: this.TriviaList,
				fullStartPosition: this.FullStartPosition,
				startPosition: this.StartPosition,
				length: this.Length,
				identity: this.Identity,
				elseKeyword: elseKeyword,
				block: block);
		}
		
		public virtual ChunkNode ToChunkNode(
			ImmutableObjectGraph.Optional<Block> programBlock = default(ImmutableObjectGraph.Optional<Block>),
			ImmutableObjectGraph.Optional<EndOfFileNode> endOfFile = default(ImmutableObjectGraph.Optional<EndOfFileNode>)) {
			ChunkNode that = this as ChunkNode;
			if (that != null && this.GetType().IsEquivalentTo(typeof(ChunkNode))) {
				if ((!programBlock.IsDefined || programBlock.Value == that.ProgramBlock) && 
				    (!endOfFile.IsDefined || endOfFile.Value == that.EndOfFile)) {
					return that;
				}
			}
		
			return ChunkNode.CreateWithIdentity(
				triviaList: this.TriviaList,
				fullStartPosition: this.FullStartPosition,
				startPosition: this.StartPosition,
				length: this.Length,
				identity: this.Identity,
				programBlock: programBlock,
				endOfFile: endOfFile);
		}
		
		public virtual EndOfFileNode ToEndOfFileNode() {
			EndOfFileNode that = this as EndOfFileNode;
			if (that != null && this.GetType().IsEquivalentTo(typeof(EndOfFileNode))) {
				return that;
			}
		
			return EndOfFileNode.CreateWithIdentity(
				triviaList: this.TriviaList,
				fullStartPosition: this.FullStartPosition,
				startPosition: this.StartPosition,
				length: this.Length,
				identity: this.Identity);
		}
		
		public virtual IfNode ToIfNode(
			ImmutableObjectGraph.Optional<Keyword> ifKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Expression> exp = default(ImmutableObjectGraph.Optional<Expression>),
			ImmutableObjectGraph.Optional<Keyword> thenKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Block> ifBlock = default(ImmutableObjectGraph.Optional<Block>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<ElseIfBlock>> elseIfList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<ElseIfBlock>>),
			ImmutableObjectGraph.Optional<ElseBlock> elseBlock = default(ImmutableObjectGraph.Optional<ElseBlock>),
			ImmutableObjectGraph.Optional<Keyword> endKeyword = default(ImmutableObjectGraph.Optional<Keyword>)) {
			IfNode that = this as IfNode;
			if (that != null && this.GetType().IsEquivalentTo(typeof(IfNode))) {
				if ((!ifKeyword.IsDefined || ifKeyword.Value == that.IfKeyword) && 
				    (!exp.IsDefined || exp.Value == that.Exp) && 
				    (!thenKeyword.IsDefined || thenKeyword.Value == that.ThenKeyword) && 
				    (!ifBlock.IsDefined || ifBlock.Value == that.IfBlock) && 
				    (!elseIfList.IsDefined || elseIfList.Value == that.ElseIfList) && 
				    (!elseBlock.IsDefined || elseBlock.Value == that.ElseBlock) && 
				    (!endKeyword.IsDefined || endKeyword.Value == that.EndKeyword)) {
					return that;
				}
			}
		
			return IfNode.CreateWithIdentity(
				triviaList: this.TriviaList,
				fullStartPosition: this.FullStartPosition,
				startPosition: this.StartPosition,
				length: this.Length,
				identity: this.Identity,
				ifKeyword: ifKeyword,
				exp: exp,
				thenKeyword: thenKeyword,
				ifBlock: ifBlock,
				elseIfList: elseIfList,
				elseBlock: elseBlock,
				endKeyword: endKeyword);
		}
		
		public virtual Expression ToExpression(
			ImmutableObjectGraph.Optional<KeyValue> keyvalue = default(ImmutableObjectGraph.Optional<KeyValue>)) {
			Expression that = this as Expression;
			if (that != null && this.GetType().IsEquivalentTo(typeof(Expression))) {
				if ((!keyvalue.IsDefined || keyvalue.Value == that.Keyvalue)) {
					return that;
				}
			}
		
			return Expression.CreateWithIdentity(
				triviaList: this.TriviaList,
				fullStartPosition: this.FullStartPosition,
				startPosition: this.StartPosition,
				length: this.Length,
				identity: this.Identity,
				keyvalue: keyvalue);
		}
		
		public virtual KeyValue ToKeyValue(
			ImmutableObjectGraph.Optional<System.String> value = default(ImmutableObjectGraph.Optional<System.String>)) {
			KeyValue that = this as KeyValue;
			if (that != null && this.GetType().IsEquivalentTo(typeof(KeyValue))) {
				if ((!value.IsDefined || value.Value == that.Value)) {
					return that;
				}
			}
		
			return KeyValue.CreateWithIdentity(
				triviaList: this.TriviaList,
				fullStartPosition: this.FullStartPosition,
				startPosition: this.StartPosition,
				length: this.Length,
				identity: this.Identity,
				value: value);
		}
		
		public virtual Keyword ToKeyword(
			ImmutableObjectGraph.Optional<System.String> value = default(ImmutableObjectGraph.Optional<System.String>)) {
			Keyword that = this as Keyword;
			if (that != null && this.GetType().IsEquivalentTo(typeof(Keyword))) {
				if ((!value.IsDefined || value.Value == that.Value)) {
					return that;
				}
			}
		
			return Keyword.CreateWithIdentity(
				triviaList: this.TriviaList,
				fullStartPosition: this.FullStartPosition,
				startPosition: this.StartPosition,
				length: this.Length,
				identity: this.Identity,
				value: value);
		}
		
		public Builder ToBuilder() {
			return new Builder(this);
		}
		
		public partial class Builder {
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			private SyntaxNode immutable;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>.Builder> triviaList;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected System.Int32 fullStartPosition;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected System.Int32 startPosition;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected System.Int32 length;
		
			internal Builder(SyntaxNode immutable) {
				this.immutable = immutable;
		
				this.fullStartPosition = immutable.FullStartPosition;
				this.startPosition = immutable.StartPosition;
				this.length = immutable.Length;
			}
		
			public System.Collections.Immutable.ImmutableList<Trivia>.Builder TriviaList {
				get {
					if (!this.triviaList.IsDefined) {
						this.triviaList = this.immutable.triviaList != null ? this.immutable.triviaList.ToBuilder() : null;
					}
		
					return this.triviaList.Value;
				}
		
				set {
					this.triviaList = value;
				}
			}
		
			public System.Int32 FullStartPosition {
				get {
					return this.fullStartPosition;
				}
		
				set {
					this.fullStartPosition = value;
				}
			}
		
			public System.Int32 StartPosition {
				get {
					return this.startPosition;
				}
		
				set {
					this.startPosition = value;
				}
			}
		
			public System.Int32 Length {
				get {
					return this.length;
				}
		
				set {
					this.length = value;
				}
			}
		
			public SyntaxNode ToImmutable() {
				var triviaList = this.triviaList.IsDefined ? (this.triviaList.Value != null ? this.triviaList.Value.ToImmutable() : null) : this.immutable.TriviaList;
				return this.immutable = this.immutable.With(
					ImmutableObjectGraph.Optional.For(triviaList),
					ImmutableObjectGraph.Optional.For(this.FullStartPosition),
					ImmutableObjectGraph.Optional.For(this.StartPosition),
					ImmutableObjectGraph.Optional.For(this.Length));
			}
		}
	
		System.UInt32 IRecursiveType.Identity {
			get { return this.Identity; }
		}
	}
	
	[System.Flags]
	public enum SyntaxNodeChangedProperties : uint {
		/// <summary>
		/// No change was made to the node.  It was either entirely added or removed. 
		/// </summary>
		None = 0x0,
	
		/// <summary>
		/// The type of the node was changed.
		/// </summary>
		Type = 0x1,
	
		/// <summary>
		/// The node's position within its parent's list of children changed.
		/// </summary>
		PositionUnderParent = 0x2,
		
		/// <summary>
		/// The node was removed and reappeared in a new position in the tree (with a different parent).
		/// </summary>
		Parent = 0x4,
	
		/// <summary>
		/// The TriviaList property was changed.
		/// </summary>
		TriviaList = 0x8,
	
		/// <summary>
		/// The FullStartPosition property was changed.
		/// </summary>
		FullStartPosition = 0x10,
	
		/// <summary>
		/// The StartPosition property was changed.
		/// </summary>
		StartPosition = 0x20,
	
		/// <summary>
		/// The Length property was changed.
		/// </summary>
		Length = 0x40,
	
		/// <summary>
		/// The ElseKeyword property was changed.
		/// </summary>
		ElseKeyword = 0x80,
	
		/// <summary>
		/// The Block property was changed.
		/// </summary>
		Block = 0x100,
	
		/// <summary>
		/// The ProgramBlock property was changed.
		/// </summary>
		ProgramBlock = 0x200,
	
		/// <summary>
		/// The EndOfFile property was changed.
		/// </summary>
		EndOfFile = 0x400,
	
		/// <summary>
		/// The IfKeyword property was changed.
		/// </summary>
		IfKeyword = 0x800,
	
		/// <summary>
		/// The Exp property was changed.
		/// </summary>
		Exp = 0x1000,
	
		/// <summary>
		/// The ThenKeyword property was changed.
		/// </summary>
		ThenKeyword = 0x2000,
	
		/// <summary>
		/// The IfBlock property was changed.
		/// </summary>
		IfBlock = 0x4000,
	
		/// <summary>
		/// The ElseIfList property was changed.
		/// </summary>
		ElseIfList = 0x8000,
	
		/// <summary>
		/// The ElseBlock property was changed.
		/// </summary>
		ElseBlock = 0x10000,
	
		/// <summary>
		/// The EndKeyword property was changed.
		/// </summary>
		EndKeyword = 0x20000,
	
		/// <summary>
		/// The Keyvalue property was changed.
		/// </summary>
		Keyvalue = 0x40000,
	
		/// <summary>
		/// The Value property was changed.
		/// </summary>
		Value = 0x80000,
	
		/// <summary>
		/// All flags in this enum.
		/// </summary>
		All = Type | PositionUnderParent | Parent | TriviaList | FullStartPosition | StartPosition | Length | ElseKeyword | Block | ProgramBlock | EndOfFile | IfKeyword | Exp | ThenKeyword | IfBlock | ElseIfList | ElseBlock | EndKeyword | Keyvalue | Value,
	}
	
	public partial class Block : SyntaxNode, System.Collections.Generic.IEnumerable<SyntaxNode>, IRecursiveParentWithOrderedChildren, IRecursiveParent<SyntaxNode>, IRecursiveParentWithFastLookup {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private static readonly Block DefaultInstance = GetDefaultTemplate();
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.Collections.Immutable.ImmutableList<SyntaxNode> children;
	
		/// <summary>Initializes a new instance of the Block class.</summary>
		protected Block(
			System.UInt32 identity,
			System.Collections.Immutable.ImmutableList<Trivia> triviaList,
			System.Int32 fullStartPosition,
			System.Int32 startPosition,
			System.Int32 length,
			System.Collections.Immutable.ImmutableList<SyntaxNode> children,
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<SyntaxNode, System.UInt32>>> lookupTable = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<SyntaxNode, System.UInt32>>>),
			ImmutableObjectGraph.Optional<bool> skipValidation = default(ImmutableObjectGraph.Optional<bool>))
			: base(
				identity: identity,
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length)
		{
			this.children = children;
			if (!skipValidation.Value) {
				this.Validate();
			}
			this.InitializeLookup(lookupTable);
		}
	
		public static Block Create(
			System.Collections.Immutable.ImmutableList<Trivia> triviaList,
			System.Int32 fullStartPosition,
			System.Int32 startPosition,
			System.Int32 length,
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<SyntaxNode>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<SyntaxNode>>)) {
			var identity = Optional.For(NewIdentity());
			return DefaultInstance.WithFactory(
				triviaList: Optional.For(triviaList),
				fullStartPosition: Optional.For(fullStartPosition),
				startPosition: Optional.For(startPosition),
				length: Optional.For(length),
				children: Optional.For(children.GetValueOrDefault(DefaultInstance.Children)),
				identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
	
		public System.Collections.Immutable.ImmutableList<SyntaxNode> Children {
			get { return this.children; }
		}
		
		/// <summary>Replaces the elements of the TriviaList collection with the specified collection.</summary>
		public new Block WithTriviaList(params Trivia[] values) {
			return (Block)base.WithTriviaList(values);
		}
		
		/// <summary>Replaces the elements of the TriviaList collection with the specified collection.</summary>
		public new Block WithTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (Block)base.WithTriviaList(values);
		}
		
		/// <summary>Adds the specified elements from the TriviaList collection.</summary>
		public new Block AddTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (Block)base.AddTriviaList(values);
		}
		
		/// <summary>Adds the specified elements from the TriviaList collection.</summary>
		public new Block AddTriviaList(params Trivia[] values) {
			return (Block)base.AddTriviaList(values);
		}
		
		/// <summary>Adds the specified element from the TriviaList collection.</summary>
		public new Block AddTriviaList(Trivia value) {
			return (Block)base.AddTriviaList(value);
		}
		
		/// <summary>Removes the specified elements from the TriviaList collection.</summary>
		public new Block RemoveTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (Block)base.RemoveTriviaList(values);
		}
		
		/// <summary>Removes the specified elements from the TriviaList collection.</summary>
		public new Block RemoveTriviaList(params Trivia[] values) {
			return (Block)base.RemoveTriviaList(values);
		}
		
		/// <summary>Removes the specified element from the TriviaList collection.</summary>
		public new Block RemoveTriviaList(Trivia value) {
			return (Block)base.RemoveTriviaList(value);
		}
		
		/// <summary>Clears all elements from the TriviaList collection.</summary>
		public new Block RemoveTriviaList() {
			return (Block)base.RemoveTriviaList();
		}
		
		
		/// <summary>Replaces the elements of the Children collection with the specified collection.</summary>
		public Block WithChildren(params SyntaxNode[] values) {
			return this.With(children: this.Children.ResetContents(values));
		}
		
		/// <summary>Replaces the elements of the Children collection with the specified collection.</summary>
		public Block WithChildren(System.Collections.Generic.IEnumerable<SyntaxNode> values) {
			return this.With(children: this.Children.ResetContents(values));
		}
		
		/// <summary>Adds the specified elements from the Children collection.</summary>
		public Block AddChildren(System.Collections.Generic.IEnumerable<SyntaxNode> values) {
			return this.With(children: this.Children.AddRange(values));
		}
		
		/// <summary>Adds the specified elements from the Children collection.</summary>
		public Block AddChildren(params SyntaxNode[] values) {
			return this.With(children: this.Children.AddRange(values));
		}
		
		/// <summary>Adds the specified element from the Children collection.</summary>
		public Block AddChild(SyntaxNode value) {
			return this.With(children: this.Children.Add(value));
		}
		
		/// <summary>Removes the specified elements from the Children collection.</summary>
		public Block RemoveChildren(System.Collections.Generic.IEnumerable<SyntaxNode> values) {
			return this.With(children: this.Children.RemoveRange(values.Select(v => this.SyncImmediateChildToCurrentVersion(v))));
		}
		
		/// <summary>Removes the specified elements from the Children collection.</summary>
		public Block RemoveChildren(params SyntaxNode[] values) {
			return this.With(children: this.Children.RemoveRange(values.Select(v => this.SyncImmediateChildToCurrentVersion(v))));
		}
		
		/// <summary>Removes the specified element from the Children collection.</summary>
		public Block RemoveChild(SyntaxNode value) {
			return this.With(children: this.Children.Remove(this.SyncImmediateChildToCurrentVersion(value)));
		}
		
		/// <summary>Clears all elements from the Children collection.</summary>
		public Block RemoveChildren() {
			return this.With(children: this.Children.Clear());
		}
		
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected override SyntaxNode WithCore(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>)) {
			return this.WithFactory(
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public Block With(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<SyntaxNode>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<SyntaxNode>>)) {
			return (Block)this.WithCore(
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length,
				children: children);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected virtual Block WithCore(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<SyntaxNode>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<SyntaxNode>>)) {
			var identity = default(ImmutableObjectGraph.Optional<System.UInt32>);
			return this.WithFactory(
				triviaList: Optional.For(triviaList.GetValueOrDefault(this.TriviaList)),
				fullStartPosition: Optional.For(fullStartPosition.GetValueOrDefault(this.FullStartPosition)),
				startPosition: Optional.For(startPosition.GetValueOrDefault(this.StartPosition)),
				length: Optional.For(length.GetValueOrDefault(this.Length)),
				children: Optional.For(children.GetValueOrDefault(this.Children)),
				identity: Optional.For(identity.GetValueOrDefault(this.Identity)));
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		private Block WithFactory(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<SyntaxNode>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<SyntaxNode>>),
			ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (
				(identity.IsDefined && identity.Value != this.Identity) || 
				(triviaList.IsDefined && triviaList.Value != this.TriviaList) || 
				(fullStartPosition.IsDefined && fullStartPosition.Value != this.FullStartPosition) || 
				(startPosition.IsDefined && startPosition.Value != this.StartPosition) || 
				(length.IsDefined && length.Value != this.Length) || 
				(children.IsDefined && children.Value != this.Children)) {
				var lookupTable = children.IsDefined && children.Value != this.Children ? default(Optional<System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<SyntaxNode, System.UInt32>>>) : Optional.For(this.lookupTable);
				return new Block(
					identity: identity.GetValueOrDefault(this.Identity),
					triviaList: triviaList.GetValueOrDefault(this.TriviaList),
					fullStartPosition: fullStartPosition.GetValueOrDefault(this.FullStartPosition),
					startPosition: startPosition.GetValueOrDefault(this.StartPosition),
					length: length.GetValueOrDefault(this.Length),
					children: children.GetValueOrDefault(this.Children),
					lookupTable: lookupTable);
			} else {
				return this;
			}
		}
	
		public System.Collections.Generic.IEnumerator<SyntaxNode> GetEnumerator() {
			return this.children.GetEnumerator();
		}
	
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
			return this.children.GetEnumerator();
		}
	
		/// <summary>Normalizes and/or validates all properties on this object.</summary>
		/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
		partial void Validate();
	
		/// <summary>Provides defaults for fields.</summary>
		/// <param name="template">The struct to set default values on.</param>
		static partial void CreateDefaultTemplate(ref Template template);
	
		/// <summary>Returns a newly instantiated Block whose fields are initialized with default values.</summary>
		private static Block GetDefaultTemplate() {
			var template = new Template();
			CreateDefaultTemplate(ref template);
			return new Block(
				default(System.UInt32),
				template.TriviaList,
				template.FullStartPosition,
				template.StartPosition,
				template.Length,
				template.Children,
				skipValidation: true);
		}
	
		/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
		private struct Template {
			internal System.Collections.Immutable.ImmutableList<Trivia> TriviaList { get; set; }
	
			internal System.Int32 FullStartPosition { get; set; }
	
			internal System.Int32 StartPosition { get; set; }
	
			internal System.Int32 Length { get; set; }
	
			internal System.Collections.Immutable.ImmutableList<SyntaxNode> Children { get; set; }
		}
		
		protected SyntaxNode SyncImmediateChildToCurrentVersion(SyntaxNode child) {
			SyntaxNode currentValue;
			if (!this.TryFindImmediateChild(child.Identity, out currentValue)) {
				throw new System.ArgumentException();
			}
		
			return currentValue;
		}
		
		public Block AddDescendent(SyntaxNode value, Block parent) {
			var spine = this.GetSpine(parent);
			var newParent = parent.AddChildren(value);
			var newSpine = System.Collections.Immutable.ImmutableStack.Create(value, newParent);
			return (Block)this.ReplaceDescendent(spine, newSpine, spineIncludesDeletedElement: false).Peek();
		}
		
		public Block RemoveDescendent(SyntaxNode value) {
			var spine = this.GetSpine(value);
			var spineList = spine.ToList();
			var parent = (Block)spineList[spineList.Count - 2];
			var newParent = parent.RemoveChildren(spineList[spineList.Count - 1]);
		
			var newSpine = System.Collections.Immutable.ImmutableStack.Create((SyntaxNode)newParent);
			return (Block)this.ReplaceDescendent(spine, newSpine, spineIncludesDeletedElement: true).Peek();
		}
		
		/// <summary>Replaces one node with a modified version of itself (same identity) among this node's descendents</summary>
		public Block ReplaceDescendent(SyntaxNode updatedNode) {
			var spine = this.GetSpine(updatedNode.Identity);
		
			if (spine.IsEmpty) {
				// The descendent was not found.
				throw new System.ArgumentException("Old value not found");
			}
		
			return (Block)this.ReplaceDescendent(spine, System.Collections.Immutable.ImmutableStack.Create(updatedNode), spineIncludesDeletedElement: false).Peek();
		}
		
		/// <summary>Replaces one node with another node that may have a different identity.</summary>
		public Block ReplaceDescendent(SyntaxNode current, SyntaxNode replacement) {
			var spine = this.GetSpine(current);
		
			if (spine.IsEmpty) {
				// The descendent was not found.
				throw new System.ArgumentException("Old value not found");
			}
		
			return (Block)this.ReplaceDescendent(spine, System.Collections.Immutable.ImmutableStack.Create(replacement), spineIncludesDeletedElement: false).Peek();
		}
		
		private System.Collections.Immutable.ImmutableStack<SyntaxNode> ReplaceDescendent(System.Collections.Immutable.ImmutableStack<SyntaxNode> spine, System.Collections.Immutable.ImmutableStack<SyntaxNode> replacementStackTip, bool spineIncludesDeletedElement) {
			Debug.Assert(this == spine.Peek());
			var remainingSpine = spine.Pop();
			if (remainingSpine.IsEmpty || (spineIncludesDeletedElement && remainingSpine.Pop().IsEmpty)) {
				// This is the instance to be changed.
				return replacementStackTip;
			}
		
			System.Collections.Immutable.ImmutableStack<SyntaxNode> newChildSpine;
			var child = remainingSpine.Peek();
			var recursiveChild = child as Block;
			if (recursiveChild != null) {
				newChildSpine = recursiveChild.ReplaceDescendent(remainingSpine, replacementStackTip, spineIncludesDeletedElement);
			} else {
				Debug.Assert(remainingSpine.Pop().IsEmpty); // we should be at the tail of the stack, since we're at a leaf.
				Debug.Assert(this.Children.Contains(child));
				newChildSpine = replacementStackTip;
			}
		
			var newChildren = this.Children.Replace(child, newChildSpine.Peek());
			var newSelf = this.WithChildren(newChildren);
			if (newSelf.lookupTable == lookupTableLazySentinal && this.lookupTable != null && this.lookupTable != lookupTableLazySentinal) {
				// Our newly mutated self wants a lookup table. If we already have one we can use it,
				// but it needs to be fixed up given the newly rewritten spine through our descendents.
				newSelf.lookupTable = this.FixupLookupTable(ImmutableDeque.Create(newChildSpine), ImmutableDeque.Create(remainingSpine));
				newSelf.ValidateInternalIntegrityDebugOnly();
			}
		
			return newChildSpine.Push(newSelf);
		}
		
		/// <summary>
		/// Produces a fast lookup table based on an existing one, if this node has one, to account for an updated spine among its descendents.
		/// </summary>
		/// <param name="updatedSpine">
		/// The spine of this node's new descendents' instances that are created for this change.
		/// The head is an immediate child of the new instance for this node.
		/// The tail is the node that was added or replaced.
		/// </param>
		/// <param name="oldSpine">
		/// The spine of this node's descendents that have been changed in this delta.
		/// The head is an immediate child of this instance.
		/// The tail is the node that was removed or replaced.
		/// </param>
		/// <returns>An updated lookup table.</returns>
		private System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<SyntaxNode, System.UInt32>> FixupLookupTable(ImmutableObjectGraph.ImmutableDeque<SyntaxNode> updatedSpine, ImmutableObjectGraph.ImmutableDeque<SyntaxNode> oldSpine) {
			if (this.lookupTable == null || this.lookupTable == lookupTableLazySentinal) {
				// We don't already have a lookup table to base this on, so leave it to the new instance to lazily construct.
				return lookupTableLazySentinal;
			}
		
			if ((updatedSpine.IsEmpty && oldSpine.IsEmpty) ||
				(updatedSpine.Count > 1 && oldSpine.Count > 1 && System.Object.ReferenceEquals(updatedSpine.PeekHead(), oldSpine.PeekHead()))) {
				// No changes were actually made.
				return this.lookupTable;
			}
		
			var lookupTable = this.lookupTable.ToBuilder();
		
			// Classify the kind of change that has just occurred.
			var oldSpineTail = oldSpine.PeekTail();
			var newSpineTail = updatedSpine.PeekTail();
			ChangeKind changeKind;
			bool childrenChanged = false;
			if (updatedSpine.Count == oldSpine.Count) {
				changeKind = ChangeKind.Replaced;
				var oldSpineTailRecursive = oldSpineTail as Block;
				var newSpineTailRecursive = newSpineTail as Block;
				if (oldSpineTailRecursive != null || newSpineTailRecursive != null) {
					// Children have changed if either before or after type didn't have a children property,
					// or if both did, but the children actually changed.
					childrenChanged = oldSpineTailRecursive == null || newSpineTailRecursive == null
						|| !System.Object.ReferenceEquals(oldSpineTailRecursive.Children, newSpineTailRecursive.Children);
				}
			} else if (updatedSpine.Count > oldSpine.Count) {
				changeKind = ChangeKind.Added;
			} else // updatedSpine.Count < oldSpine.Count
			{
				changeKind = ChangeKind.Removed;
			}
		
			// Trim the lookup table of any entries for nodes that have been removed from the tree.
			if (childrenChanged || changeKind == ChangeKind.Removed) {
				// We need to remove all descendents of the old tail node.
				lookupTable.RemoveRange(oldSpineTail.GetSelfAndDescendents().Select(n => n.Identity));
			} else if (changeKind == ChangeKind.Replaced && oldSpineTail.Identity != newSpineTail.Identity) {
				// The identity of the node was changed during the replacement.  We must explicitly remove the old entry
				// from our lookup table in this case.
				lookupTable.Remove(oldSpineTail.Identity);
		
				// We also need to update any immediate children of the old spine tail
				// because the identity of their parent has changed.
				var oldSpineTailRecursive = oldSpineTail as Block;
				if (oldSpineTailRecursive != null) {
					foreach (var child in oldSpineTailRecursive) {
						lookupTable[child.Identity] = new System.Collections.Generic.KeyValuePair<SyntaxNode, System.UInt32>(child, newSpineTail.Identity);
					}
				}
			}
		
			// Update our lookup table so that it includes (updated) entries for every member of the spine itself.
			SyntaxNode parent = this;
			foreach (var node in updatedSpine) {
				// Remove and add rather than use the Set method, since the old and new node are equal (in identity) therefore the map class will
				// assume no change is relevant and not apply the change.
				lookupTable.Remove(node.Identity);
				lookupTable.Add(node.Identity, new System.Collections.Generic.KeyValuePair<SyntaxNode, System.UInt32>(node, parent.Identity));
				parent = node;
			}
		
			// There may be children on the added node that we should include.
			if (childrenChanged || changeKind == ChangeKind.Added) {
				var recursiveParent = parent as Block;
				if (recursiveParent != null) {
					recursiveParent.ContributeDescendentsToLookupTable(lookupTable);
				}
			}
		
			return lookupTable.ToImmutable();
		}
		
		/// <summary>
		/// Validates this node and all its descendents <em>only in DEBUG builds</em>.
		/// </summary>
		[Conditional("DEBUG")]
		private void ValidateInternalIntegrityDebugOnly() {
			this.ValidateInternalIntegrity();
		}
		
		/// <summary>
		/// Validates this node and all its descendents.
		/// </summary>
		protected internal void ValidateInternalIntegrity() {
			// Each node id appears at most once.
			var observedIdentities = new System.Collections.Generic.HashSet<System.UInt32>();
			foreach (var node in this.GetSelfAndDescendents()) {
				if (!observedIdentities.Add(node.Identity)) {
					throw new RecursiveChildNotUniqueException(node.Identity);
				}
			}
		
			// The lookup table (if any) accurately describes the contents of this tree.
			if (this.lookupTable != null && this.lookupTable != lookupTableLazySentinal) {
				// The table should have one entry for every *descendent* of this node (not this node itself).
				int expectedCount = this.GetSelfAndDescendents().Count() - 1;
				int actualCount = this.lookupTable.Count;
				if (actualCount != expectedCount) {
					throw new System.ApplicationException(string.Format(System.Globalization.CultureInfo.CurrentCulture, "Expected {0} entries in lookup table but found {1}.", expectedCount, actualCount));
				}
		
				this.ValidateLookupTable(this.lookupTable);
			}
		}
		
		/// <summary>
		/// Validates that the contents of a lookup table are valid for all descendent nodes of this node.
		/// </summary>
		/// <param name="lookupTable">The lookup table being validated.</param>
		private void ValidateLookupTable(System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<SyntaxNode, System.UInt32>> lookupTable) {
			const string ErrorString = "Lookup table integrity failure.";
		
			foreach (var child in this.Children) {
				var entry = lookupTable[child.Identity];
				if (!object.ReferenceEquals(entry.Key, child)) {
					throw new System.ApplicationException(ErrorString);
				}
		
				if (entry.Value != this.Identity) {
					throw new System.ApplicationException(ErrorString);
				}
		
				var recursiveChild = child as Block;
				if (recursiveChild != null) {
					recursiveChild.ValidateLookupTable(lookupTable);
				}
			}
		}
		
		private static readonly System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<SyntaxNode, System.UInt32>> lookupTableLazySentinal = System.Collections.Immutable.ImmutableDictionary.Create<System.UInt32, System.Collections.Generic.KeyValuePair<SyntaxNode, System.UInt32>>().Add(default(System.UInt32), new System.Collections.Generic.KeyValuePair<SyntaxNode, System.UInt32>());
		
		private System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<SyntaxNode, System.UInt32>> lookupTable;
		
		private int inefficiencyLoad;
		
		/// <summary>
		/// The maximum number of steps allowable for a search to be done among this node's children
		/// before a faster lookup table will be built.
		/// </summary>
		internal const int InefficiencyLoadThreshold = 16;
		
		private System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<SyntaxNode, System.UInt32>> LookupTable {
			get {
				if (this.lookupTable == lookupTableLazySentinal) {
					this.lookupTable = this.CreateLookupTable();
					this.inefficiencyLoad = 1;
				}
		
				return this.lookupTable;
			}
		}
		
		bool IRecursiveParentWithFastLookup.TryLookup(System.UInt32 identity, out System.Collections.Generic.KeyValuePair<IRecursiveType, System.UInt32> result) {
			if (this.LookupTable != null) {
				System.Collections.Generic.KeyValuePair<SyntaxNode, System.UInt32> typedResult;
				this.LookupTable.TryGetValue(identity, out typedResult);
				result = new System.Collections.Generic.KeyValuePair<IRecursiveType, System.UInt32>(typedResult.Key, typedResult.Value);
				return true;
			}
		
			result = default(System.Collections.Generic.KeyValuePair<IRecursiveType, System.UInt32>);
			return false;
		}
		
		private void InitializeLookup(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<SyntaxNode, System.UInt32>>> priorLookupTable = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<SyntaxNode, System.UInt32>>>)) {
			int inefficiencyLoad = 1; // use local until we know final value since that's faster than field access.
			if (priorLookupTable.IsDefined && priorLookupTable.Value != null) {
				this.lookupTable = priorLookupTable.Value;
			} else {
				if (this.children != null) {
					if (this.children.Count >= InefficiencyLoadThreshold) {
						// The number of children alone are enough to put us over the threshold, skip enumeration.
						inefficiencyLoad = InefficiencyLoadThreshold + 1;
					} else if (this.children.Count > 0) {
						foreach (var child in this.children) {
							var recursiveChild = child as Block;
							inefficiencyLoad += recursiveChild != null ? recursiveChild.inefficiencyLoad : 1;
							if (inefficiencyLoad > InefficiencyLoadThreshold) {
								break; // It's ok to under-estimate once we're above the threshold since any further would be a waste of time.
							}
						}
					}
				}
		
				if (inefficiencyLoad > InefficiencyLoadThreshold) {
					inefficiencyLoad = 1;
					this.lookupTable = lookupTableLazySentinal;
				}
			}
		
			this.inefficiencyLoad = inefficiencyLoad;
			this.ValidateInternalIntegrityDebugOnly();
		}
		
		/// <summary>
		/// Creates the lookup table that will contain all this node's children.
		/// </summary>
		/// <returns>The lookup table.</returns>
		private System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<SyntaxNode, System.UInt32>> CreateLookupTable() {
			var table = System.Collections.Immutable.ImmutableDictionary.Create<System.UInt32, System.Collections.Generic.KeyValuePair<SyntaxNode, System.UInt32>>().ToBuilder();
			this.ContributeDescendentsToLookupTable(table);
			return table.ToImmutable();
		}
		
		/// <summary>
		/// Adds this node's children (recursively) to the lookup table.
		/// </summary>
		/// <param name="seedLookupTable">The lookup table to add entries to.</param>
		/// <returns>The new lookup table.</returns>
		private void ContributeDescendentsToLookupTable(System.Collections.Immutable.ImmutableDictionary<System.UInt32, System.Collections.Generic.KeyValuePair<SyntaxNode, System.UInt32>>.Builder seedLookupTable)
		{
			foreach (var child in this.Children)
			{
				seedLookupTable.Add(child.Identity, new System.Collections.Generic.KeyValuePair<SyntaxNode, System.UInt32>(child, this.Identity));
				var recursiveChild = child as Block;
				if (recursiveChild != null) {
					recursiveChild.ContributeDescendentsToLookupTable(seedLookupTable);
				}
			}
		}
		
		public SyntaxNode Find(System.UInt32 identity) {
			SyntaxNode result;
			if (this.TryFind(identity, out result)) {
				return result;
			}
		
			throw new System.Collections.Generic.KeyNotFoundException();
		}
		
		/// <summary>Gets the recursive parent of the specified value, or <c>null</c> if none could be found.</summary>
		internal ParentedRecursiveType<Block, SyntaxNode> GetParentedNode(System.UInt32 identity) {
			if (this.Identity == identity) {
				return new ParentedRecursiveType<Block, SyntaxNode>(this, null);
			}
		
			if (this.LookupTable != null) {
				System.Collections.Generic.KeyValuePair<SyntaxNode, System.UInt32> lookupValue;
				if (this.LookupTable.TryGetValue(identity, out lookupValue)) {
					var parentIdentity = lookupValue.Value;
					return new ParentedRecursiveType<Block, SyntaxNode>(this.LookupTable[identity].Key, (Block)this.Find(parentIdentity));
				}
			} else {
				// No lookup table means we have to aggressively search each child.
				foreach (var child in this.Children) {
					if (child.Identity.Equals(identity)) {
						return new ParentedRecursiveType<Block, SyntaxNode>(child, this);
					}
		
					var recursiveChild = child as Block;
					if (recursiveChild != null) {
						var childResult = recursiveChild.GetParentedNode(identity);
						if (childResult.Value != null) {
							return childResult;
						}
					} 
				}
			}
		
			return default(ParentedRecursiveType<Block, SyntaxNode>);
		}
		
		/// <summary>Gets the recursive parent of the specified value, or <c>null</c> if none could be found.</summary>
		internal Block GetParent(SyntaxNode descendent) {
			return this.GetParentedNode(descendent.Identity).Parent;
		}
		
		public System.Collections.Immutable.ImmutableStack<SyntaxNode> GetSpine(System.UInt32 descendent) {
			var emptySpine = System.Collections.Immutable.ImmutableStack.Create<SyntaxNode>();
			if (this.Identity.Equals(descendent)) {
				return emptySpine.Push(this);
			}
		
			if (this.LookupTable != null) {
				System.Collections.Generic.KeyValuePair<SyntaxNode, System.UInt32> lookupValue;
				if (this.LookupTable.TryGetValue(descendent, out lookupValue))
				{
					// Awesome.  We know the node the caller is looking for is a descendent of this node.
					// Now just string together all the nodes that connect this one with the sought one.
					var spine = emptySpine;
					do
					{
						spine = spine.Push(lookupValue.Key);
					}
					while (this.lookupTable.TryGetValue(lookupValue.Value, out lookupValue));
					return spine.Push(this);
				}
			} else {
				// We don't have an efficient lookup table for this node.  Aggressively search every child.
				var spine = emptySpine;
				foreach (var child in this.Children) {
					var recursiveChild = child as Block;
					if (recursiveChild != null) {
						spine = recursiveChild.GetSpine(descendent);
					} else if (child.Identity.Equals(descendent)) {
						spine = spine.Push(child);
					}
		
					if (!spine.IsEmpty) {
						return spine.Push(this);
					}
				}
			}
		
			// The descendent is not in this sub-tree.
			return emptySpine;
		}
		
		public System.Collections.Immutable.ImmutableStack<SyntaxNode> GetSpine(SyntaxNode descendent) {
			return this.GetSpine(descendent.Identity);
		}
		
		internal static Block CreateWithIdentity(
				System.Collections.Immutable.ImmutableList<Trivia> triviaList,
				System.Int32 fullStartPosition,
				System.Int32 startPosition,
				System.Int32 length,
				ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<SyntaxNode>> children = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<SyntaxNode>>),
				ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (!identity.IsDefined) {
				identity = NewIdentity();
			}
		
			return DefaultInstance.WithFactory(
					triviaList: Optional.For(triviaList),
					fullStartPosition: Optional.For(fullStartPosition),
					startPosition: Optional.For(startPosition),
					length: Optional.For(length),
					children: Optional.For(children.GetValueOrDefault(DefaultInstance.Children)),
					identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
		
		public new Builder ToBuilder() {
			return new Builder(this);
		}
		
		public static new Builder CreateBuilder() {
			return new Builder(DefaultInstance);
		}
		
		public new partial class Builder : SyntaxNode.Builder {
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			private Block immutable;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<SyntaxNode>.Builder> children;
		
			internal Builder(Block immutable) : base(immutable) {
				this.immutable = immutable;
		
			}
		
			public System.Collections.Immutable.ImmutableList<SyntaxNode>.Builder Children {
				get {
					if (!this.children.IsDefined) {
						this.children = this.immutable.children != null ? this.immutable.children.ToBuilder() : null;
					}
		
					return this.children.Value;
				}
		
				set {
					this.children = value;
				}
			}
		
			public new Block ToImmutable() {
				var triviaList = this.triviaList.IsDefined ? (this.triviaList.Value != null ? this.triviaList.Value.ToImmutable() : null) : this.immutable.TriviaList;
				var children = this.children.IsDefined ? (this.children.Value != null ? this.children.Value.ToImmutable() : null) : this.immutable.Children;
				return this.immutable = this.immutable.With(
					ImmutableObjectGraph.Optional.For(triviaList),
					ImmutableObjectGraph.Optional.For(this.FullStartPosition),
					ImmutableObjectGraph.Optional.For(this.StartPosition),
					ImmutableObjectGraph.Optional.For(this.Length),
					ImmutableObjectGraph.Optional.For(children));
			}
		}
	
		System.Collections.Generic.IEnumerable<IRecursiveType> IRecursiveParent.Children {
			get { return this.Children; }
		}
	
		System.Collections.Generic.IEnumerable<SyntaxNode> IRecursiveParent<SyntaxNode>.Children {
			get { return this.Children; }
		}
	
		ParentedRecursiveType<IRecursiveParent<IRecursiveType>, IRecursiveType> IRecursiveParent.GetParentedNode(System.UInt32 identity) {
			var parented = this.GetParentedNode(identity);
			return new ParentedRecursiveType<IRecursiveParent<IRecursiveType>, IRecursiveType>(parented.Value, parented.Parent);
		}
		int IRecursiveParentWithOrderedChildren.IndexOf(IRecursiveType value) {
			return this.Children.IndexOf((SyntaxNode)value);
		}
	}
	
	public partial class ElseBlock : SyntaxNode {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private static readonly ElseBlock DefaultInstance = GetDefaultTemplate();
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly Keyword elseKeyword;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly Block block;
	
		/// <summary>Initializes a new instance of the ElseBlock class.</summary>
		protected ElseBlock(
			System.UInt32 identity,
			System.Collections.Immutable.ImmutableList<Trivia> triviaList,
			System.Int32 fullStartPosition,
			System.Int32 startPosition,
			System.Int32 length,
			Keyword elseKeyword,
			Block block,
			ImmutableObjectGraph.Optional<bool> skipValidation = default(ImmutableObjectGraph.Optional<bool>))
			: base(
				identity: identity,
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length)
		{
			this.elseKeyword = elseKeyword;
			this.block = block;
			if (!skipValidation.Value) {
				this.Validate();
			}
		}
	
		public static ElseBlock Create(
			System.Collections.Immutable.ImmutableList<Trivia> triviaList,
			System.Int32 fullStartPosition,
			System.Int32 startPosition,
			System.Int32 length,
			ImmutableObjectGraph.Optional<Keyword> elseKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Block> block = default(ImmutableObjectGraph.Optional<Block>)) {
			var identity = Optional.For(NewIdentity());
			return DefaultInstance.WithFactory(
				triviaList: Optional.For(triviaList),
				fullStartPosition: Optional.For(fullStartPosition),
				startPosition: Optional.For(startPosition),
				length: Optional.For(length),
				elseKeyword: Optional.For(elseKeyword.GetValueOrDefault(DefaultInstance.ElseKeyword)),
				block: Optional.For(block.GetValueOrDefault(DefaultInstance.Block)),
				identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
	
		public Keyword ElseKeyword {
			get { return this.elseKeyword; }
		}
	
		public Block Block {
			get { return this.block; }
		}
		
		/// <summary>Replaces the elements of the TriviaList collection with the specified collection.</summary>
		public new ElseBlock WithTriviaList(params Trivia[] values) {
			return (ElseBlock)base.WithTriviaList(values);
		}
		
		/// <summary>Replaces the elements of the TriviaList collection with the specified collection.</summary>
		public new ElseBlock WithTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (ElseBlock)base.WithTriviaList(values);
		}
		
		/// <summary>Adds the specified elements from the TriviaList collection.</summary>
		public new ElseBlock AddTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (ElseBlock)base.AddTriviaList(values);
		}
		
		/// <summary>Adds the specified elements from the TriviaList collection.</summary>
		public new ElseBlock AddTriviaList(params Trivia[] values) {
			return (ElseBlock)base.AddTriviaList(values);
		}
		
		/// <summary>Adds the specified element from the TriviaList collection.</summary>
		public new ElseBlock AddTriviaList(Trivia value) {
			return (ElseBlock)base.AddTriviaList(value);
		}
		
		/// <summary>Removes the specified elements from the TriviaList collection.</summary>
		public new ElseBlock RemoveTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (ElseBlock)base.RemoveTriviaList(values);
		}
		
		/// <summary>Removes the specified elements from the TriviaList collection.</summary>
		public new ElseBlock RemoveTriviaList(params Trivia[] values) {
			return (ElseBlock)base.RemoveTriviaList(values);
		}
		
		/// <summary>Removes the specified element from the TriviaList collection.</summary>
		public new ElseBlock RemoveTriviaList(Trivia value) {
			return (ElseBlock)base.RemoveTriviaList(value);
		}
		
		/// <summary>Clears all elements from the TriviaList collection.</summary>
		public new ElseBlock RemoveTriviaList() {
			return (ElseBlock)base.RemoveTriviaList();
		}
		
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected override SyntaxNode WithCore(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>)) {
			return this.WithFactory(
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public ElseBlock With(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<Keyword> elseKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Block> block = default(ImmutableObjectGraph.Optional<Block>)) {
			return (ElseBlock)this.WithCore(
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length,
				elseKeyword: elseKeyword,
				block: block);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected virtual ElseBlock WithCore(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<Keyword> elseKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Block> block = default(ImmutableObjectGraph.Optional<Block>)) {
			var identity = default(ImmutableObjectGraph.Optional<System.UInt32>);
			return this.WithFactory(
				triviaList: Optional.For(triviaList.GetValueOrDefault(this.TriviaList)),
				fullStartPosition: Optional.For(fullStartPosition.GetValueOrDefault(this.FullStartPosition)),
				startPosition: Optional.For(startPosition.GetValueOrDefault(this.StartPosition)),
				length: Optional.For(length.GetValueOrDefault(this.Length)),
				elseKeyword: Optional.For(elseKeyword.GetValueOrDefault(this.ElseKeyword)),
				block: Optional.For(block.GetValueOrDefault(this.Block)),
				identity: Optional.For(identity.GetValueOrDefault(this.Identity)));
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		private ElseBlock WithFactory(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<Keyword> elseKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Block> block = default(ImmutableObjectGraph.Optional<Block>),
			ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (
				(identity.IsDefined && identity.Value != this.Identity) || 
				(triviaList.IsDefined && triviaList.Value != this.TriviaList) || 
				(fullStartPosition.IsDefined && fullStartPosition.Value != this.FullStartPosition) || 
				(startPosition.IsDefined && startPosition.Value != this.StartPosition) || 
				(length.IsDefined && length.Value != this.Length) || 
				(elseKeyword.IsDefined && elseKeyword.Value != this.ElseKeyword) || 
				(block.IsDefined && block.Value != this.Block)) {
				return new ElseBlock(
					identity: identity.GetValueOrDefault(this.Identity),
					triviaList: triviaList.GetValueOrDefault(this.TriviaList),
					fullStartPosition: fullStartPosition.GetValueOrDefault(this.FullStartPosition),
					startPosition: startPosition.GetValueOrDefault(this.StartPosition),
					length: length.GetValueOrDefault(this.Length),
					elseKeyword: elseKeyword.GetValueOrDefault(this.ElseKeyword),
					block: block.GetValueOrDefault(this.Block));
			} else {
				return this;
			}
		}
	
		/// <summary>Normalizes and/or validates all properties on this object.</summary>
		/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
		partial void Validate();
	
		/// <summary>Provides defaults for fields.</summary>
		/// <param name="template">The struct to set default values on.</param>
		static partial void CreateDefaultTemplate(ref Template template);
	
		/// <summary>Returns a newly instantiated ElseBlock whose fields are initialized with default values.</summary>
		private static ElseBlock GetDefaultTemplate() {
			var template = new Template();
			CreateDefaultTemplate(ref template);
			return new ElseBlock(
				default(System.UInt32),
				template.TriviaList,
				template.FullStartPosition,
				template.StartPosition,
				template.Length,
				template.ElseKeyword,
				template.Block,
				skipValidation: true);
		}
	
		/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
		private struct Template {
			internal System.Collections.Immutable.ImmutableList<Trivia> TriviaList { get; set; }
	
			internal System.Int32 FullStartPosition { get; set; }
	
			internal System.Int32 StartPosition { get; set; }
	
			internal System.Int32 Length { get; set; }
	
			internal Keyword ElseKeyword { get; set; }
	
			internal Block Block { get; set; }
		}
		
		protected override SyntaxNodeChangedProperties DiffProperties(SyntaxNode other) {
			var propertiesChanged = base.DiffProperties(other);
		
			var otherElseBlock = other as ElseBlock;
			if (otherElseBlock != null) {
				if (this.ElseKeyword != otherElseBlock.ElseKeyword) {
					propertiesChanged |= SyntaxNodeChangedProperties.ElseKeyword;
				}
		
				if (this.Block != otherElseBlock.Block) {
					propertiesChanged |= SyntaxNodeChangedProperties.Block;
				}
			}
		
			return propertiesChanged;
		}
		
		internal static ElseBlock CreateWithIdentity(
				System.Collections.Immutable.ImmutableList<Trivia> triviaList,
				System.Int32 fullStartPosition,
				System.Int32 startPosition,
				System.Int32 length,
				ImmutableObjectGraph.Optional<Keyword> elseKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
				ImmutableObjectGraph.Optional<Block> block = default(ImmutableObjectGraph.Optional<Block>),
				ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (!identity.IsDefined) {
				identity = NewIdentity();
			}
		
			return DefaultInstance.WithFactory(
					triviaList: Optional.For(triviaList),
					fullStartPosition: Optional.For(fullStartPosition),
					startPosition: Optional.For(startPosition),
					length: Optional.For(length),
					elseKeyword: Optional.For(elseKeyword.GetValueOrDefault(DefaultInstance.ElseKeyword)),
					block: Optional.For(block.GetValueOrDefault(DefaultInstance.Block)),
					identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
		
		public new Builder ToBuilder() {
			return new Builder(this);
		}
		
		public static new Builder CreateBuilder() {
			return new Builder(DefaultInstance);
		}
		
		public new partial class Builder : SyntaxNode.Builder {
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			private ElseBlock immutable;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected ImmutableObjectGraph.Optional<Keyword.Builder> elseKeyword;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected ImmutableObjectGraph.Optional<Block.Builder> block;
		
			internal Builder(ElseBlock immutable) : base(immutable) {
				this.immutable = immutable;
		
			}
		
			public Keyword.Builder ElseKeyword {
				get {
					if (!this.elseKeyword.IsDefined) {
						this.elseKeyword = this.immutable.elseKeyword != null ? this.immutable.elseKeyword.ToBuilder() : null;
					}
		
					return this.elseKeyword.Value;
				}
		
				set {
					this.elseKeyword = value;
				}
			}
		
			public Block.Builder Block {
				get {
					if (!this.block.IsDefined) {
						this.block = this.immutable.block != null ? this.immutable.block.ToBuilder() : null;
					}
		
					return this.block.Value;
				}
		
				set {
					this.block = value;
				}
			}
		
			public new ElseBlock ToImmutable() {
				var triviaList = this.triviaList.IsDefined ? (this.triviaList.Value != null ? this.triviaList.Value.ToImmutable() : null) : this.immutable.TriviaList;
				var elseKeyword = this.elseKeyword.IsDefined ? (this.elseKeyword.Value != null ? this.elseKeyword.Value.ToImmutable() : null) : this.immutable.ElseKeyword;
				var block = this.block.IsDefined ? (this.block.Value != null ? this.block.Value.ToImmutable() : null) : this.immutable.Block;
				return this.immutable = this.immutable.With(
					ImmutableObjectGraph.Optional.For(triviaList),
					ImmutableObjectGraph.Optional.For(this.FullStartPosition),
					ImmutableObjectGraph.Optional.For(this.StartPosition),
					ImmutableObjectGraph.Optional.For(this.Length),
					ImmutableObjectGraph.Optional.For(elseKeyword),
					ImmutableObjectGraph.Optional.For(block));
			}
		}
	}
	
	public partial class ElseIfBlock {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private static readonly ElseIfBlock DefaultInstance = GetDefaultTemplate();
		
		/// <summary>The last identity assigned to a created instance.</summary>
		private static int lastIdentityProduced;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly Keyword elseIfKeyword;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly Expression exp;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly Keyword thenKeyword;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly Block block;
	
		private readonly System.UInt32 identity;
	
		/// <summary>Initializes a new instance of the ElseIfBlock class.</summary>
		protected ElseIfBlock(
			System.UInt32 identity,
			Keyword elseIfKeyword,
			Expression exp,
			Keyword thenKeyword,
			Block block,
			ImmutableObjectGraph.Optional<bool> skipValidation = default(ImmutableObjectGraph.Optional<bool>))
		{
			this.identity = identity;
			this.elseIfKeyword = elseIfKeyword;
			this.exp = exp;
			this.thenKeyword = thenKeyword;
			this.block = block;
			if (!skipValidation.Value) {
				this.Validate();
			}
		}
	
		public static ElseIfBlock Create(
			ImmutableObjectGraph.Optional<Keyword> elseIfKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Expression> exp = default(ImmutableObjectGraph.Optional<Expression>),
			ImmutableObjectGraph.Optional<Keyword> thenKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Block> block = default(ImmutableObjectGraph.Optional<Block>)) {
			var identity = Optional.For(NewIdentity());
			return DefaultInstance.WithFactory(
				elseIfKeyword: Optional.For(elseIfKeyword.GetValueOrDefault(DefaultInstance.ElseIfKeyword)),
				exp: Optional.For(exp.GetValueOrDefault(DefaultInstance.Exp)),
				thenKeyword: Optional.For(thenKeyword.GetValueOrDefault(DefaultInstance.ThenKeyword)),
				block: Optional.For(block.GetValueOrDefault(DefaultInstance.Block)),
				identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
	
		public Keyword ElseIfKeyword {
			get { return this.elseIfKeyword; }
		}
	
		public Expression Exp {
			get { return this.exp; }
		}
	
		public Keyword ThenKeyword {
			get { return this.thenKeyword; }
		}
	
		public Block Block {
			get { return this.block; }
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public ElseIfBlock With(
			ImmutableObjectGraph.Optional<Keyword> elseIfKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Expression> exp = default(ImmutableObjectGraph.Optional<Expression>),
			ImmutableObjectGraph.Optional<Keyword> thenKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Block> block = default(ImmutableObjectGraph.Optional<Block>)) {
			return (ElseIfBlock)this.WithCore(
				elseIfKeyword: elseIfKeyword,
				exp: exp,
				thenKeyword: thenKeyword,
				block: block);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected virtual ElseIfBlock WithCore(
			ImmutableObjectGraph.Optional<Keyword> elseIfKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Expression> exp = default(ImmutableObjectGraph.Optional<Expression>),
			ImmutableObjectGraph.Optional<Keyword> thenKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Block> block = default(ImmutableObjectGraph.Optional<Block>)) {
			var identity = default(ImmutableObjectGraph.Optional<System.UInt32>);
			return this.WithFactory(
				elseIfKeyword: Optional.For(elseIfKeyword.GetValueOrDefault(this.ElseIfKeyword)),
				exp: Optional.For(exp.GetValueOrDefault(this.Exp)),
				thenKeyword: Optional.For(thenKeyword.GetValueOrDefault(this.ThenKeyword)),
				block: Optional.For(block.GetValueOrDefault(this.Block)),
				identity: Optional.For(identity.GetValueOrDefault(this.Identity)));
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		private ElseIfBlock WithFactory(
			ImmutableObjectGraph.Optional<Keyword> elseIfKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Expression> exp = default(ImmutableObjectGraph.Optional<Expression>),
			ImmutableObjectGraph.Optional<Keyword> thenKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Block> block = default(ImmutableObjectGraph.Optional<Block>),
			ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (
				(identity.IsDefined && identity.Value != this.Identity) || 
				(elseIfKeyword.IsDefined && elseIfKeyword.Value != this.ElseIfKeyword) || 
				(exp.IsDefined && exp.Value != this.Exp) || 
				(thenKeyword.IsDefined && thenKeyword.Value != this.ThenKeyword) || 
				(block.IsDefined && block.Value != this.Block)) {
				return new ElseIfBlock(
					identity: identity.GetValueOrDefault(this.Identity),
					elseIfKeyword: elseIfKeyword.GetValueOrDefault(this.ElseIfKeyword),
					exp: exp.GetValueOrDefault(this.Exp),
					thenKeyword: thenKeyword.GetValueOrDefault(this.ThenKeyword),
					block: block.GetValueOrDefault(this.Block));
			} else {
				return this;
			}
		}
	
		protected internal uint Identity {
			get { return (uint)this.identity; }
		}
	
		/// <summary>Returns a unique identity that may be assigned to a newly created instance.</summary>
		protected static System.UInt32 NewIdentity() {
			return (System.UInt32)System.Threading.Interlocked.Increment(ref lastIdentityProduced);
		}
	
		/// <summary>Normalizes and/or validates all properties on this object.</summary>
		/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
		partial void Validate();
	
		/// <summary>Provides defaults for fields.</summary>
		/// <param name="template">The struct to set default values on.</param>
		static partial void CreateDefaultTemplate(ref Template template);
	
		/// <summary>Returns a newly instantiated ElseIfBlock whose fields are initialized with default values.</summary>
		private static ElseIfBlock GetDefaultTemplate() {
			var template = new Template();
			CreateDefaultTemplate(ref template);
			return new ElseIfBlock(
				default(System.UInt32),
				template.ElseIfKeyword,
				template.Exp,
				template.ThenKeyword,
				template.Block,
				skipValidation: true);
		}
	
		/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
		private struct Template {
			internal Keyword ElseIfKeyword { get; set; }
	
			internal Expression Exp { get; set; }
	
			internal Keyword ThenKeyword { get; set; }
	
			internal Block Block { get; set; }
		}
		
		public Builder ToBuilder() {
			return new Builder(this);
		}
		
		public static Builder CreateBuilder() {
			return new Builder(DefaultInstance);
		}
		
		public partial class Builder {
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			private ElseIfBlock immutable;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected ImmutableObjectGraph.Optional<Keyword.Builder> elseIfKeyword;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected ImmutableObjectGraph.Optional<Expression.Builder> exp;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected ImmutableObjectGraph.Optional<Keyword.Builder> thenKeyword;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected ImmutableObjectGraph.Optional<Block.Builder> block;
		
			internal Builder(ElseIfBlock immutable) {
				this.immutable = immutable;
		
			}
		
			public Keyword.Builder ElseIfKeyword {
				get {
					if (!this.elseIfKeyword.IsDefined) {
						this.elseIfKeyword = this.immutable.elseIfKeyword != null ? this.immutable.elseIfKeyword.ToBuilder() : null;
					}
		
					return this.elseIfKeyword.Value;
				}
		
				set {
					this.elseIfKeyword = value;
				}
			}
		
			public Expression.Builder Exp {
				get {
					if (!this.exp.IsDefined) {
						this.exp = this.immutable.exp != null ? this.immutable.exp.ToBuilder() : null;
					}
		
					return this.exp.Value;
				}
		
				set {
					this.exp = value;
				}
			}
		
			public Keyword.Builder ThenKeyword {
				get {
					if (!this.thenKeyword.IsDefined) {
						this.thenKeyword = this.immutable.thenKeyword != null ? this.immutable.thenKeyword.ToBuilder() : null;
					}
		
					return this.thenKeyword.Value;
				}
		
				set {
					this.thenKeyword = value;
				}
			}
		
			public Block.Builder Block {
				get {
					if (!this.block.IsDefined) {
						this.block = this.immutable.block != null ? this.immutable.block.ToBuilder() : null;
					}
		
					return this.block.Value;
				}
		
				set {
					this.block = value;
				}
			}
		
			public ElseIfBlock ToImmutable() {
				var elseIfKeyword = this.elseIfKeyword.IsDefined ? (this.elseIfKeyword.Value != null ? this.elseIfKeyword.Value.ToImmutable() : null) : this.immutable.ElseIfKeyword;
				var exp = this.exp.IsDefined ? (this.exp.Value != null ? this.exp.Value.ToImmutable() : null) : this.immutable.Exp;
				var thenKeyword = this.thenKeyword.IsDefined ? (this.thenKeyword.Value != null ? this.thenKeyword.Value.ToImmutable() : null) : this.immutable.ThenKeyword;
				var block = this.block.IsDefined ? (this.block.Value != null ? this.block.Value.ToImmutable() : null) : this.immutable.Block;
				return this.immutable = this.immutable.With(
					ImmutableObjectGraph.Optional.For(elseIfKeyword),
					ImmutableObjectGraph.Optional.For(exp),
					ImmutableObjectGraph.Optional.For(thenKeyword),
					ImmutableObjectGraph.Optional.For(block));
			}
		}
	}
	
	public partial class ChunkNode : SyntaxNode {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private static readonly ChunkNode DefaultInstance = GetDefaultTemplate();
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly Block programBlock;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly EndOfFileNode endOfFile;
	
		/// <summary>Initializes a new instance of the ChunkNode class.</summary>
		protected ChunkNode(
			System.UInt32 identity,
			System.Collections.Immutable.ImmutableList<Trivia> triviaList,
			System.Int32 fullStartPosition,
			System.Int32 startPosition,
			System.Int32 length,
			Block programBlock,
			EndOfFileNode endOfFile,
			ImmutableObjectGraph.Optional<bool> skipValidation = default(ImmutableObjectGraph.Optional<bool>))
			: base(
				identity: identity,
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length)
		{
			this.programBlock = programBlock;
			this.endOfFile = endOfFile;
			if (!skipValidation.Value) {
				this.Validate();
			}
		}
	
		public static ChunkNode Create(
			System.Collections.Immutable.ImmutableList<Trivia> triviaList,
			System.Int32 fullStartPosition,
			System.Int32 startPosition,
			System.Int32 length,
			ImmutableObjectGraph.Optional<Block> programBlock = default(ImmutableObjectGraph.Optional<Block>),
			ImmutableObjectGraph.Optional<EndOfFileNode> endOfFile = default(ImmutableObjectGraph.Optional<EndOfFileNode>)) {
			var identity = Optional.For(NewIdentity());
			return DefaultInstance.WithFactory(
				triviaList: Optional.For(triviaList),
				fullStartPosition: Optional.For(fullStartPosition),
				startPosition: Optional.For(startPosition),
				length: Optional.For(length),
				programBlock: Optional.For(programBlock.GetValueOrDefault(DefaultInstance.ProgramBlock)),
				endOfFile: Optional.For(endOfFile.GetValueOrDefault(DefaultInstance.EndOfFile)),
				identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
	
		public Block ProgramBlock {
			get { return this.programBlock; }
		}
	
		public EndOfFileNode EndOfFile {
			get { return this.endOfFile; }
		}
		
		/// <summary>Replaces the elements of the TriviaList collection with the specified collection.</summary>
		public new ChunkNode WithTriviaList(params Trivia[] values) {
			return (ChunkNode)base.WithTriviaList(values);
		}
		
		/// <summary>Replaces the elements of the TriviaList collection with the specified collection.</summary>
		public new ChunkNode WithTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (ChunkNode)base.WithTriviaList(values);
		}
		
		/// <summary>Adds the specified elements from the TriviaList collection.</summary>
		public new ChunkNode AddTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (ChunkNode)base.AddTriviaList(values);
		}
		
		/// <summary>Adds the specified elements from the TriviaList collection.</summary>
		public new ChunkNode AddTriviaList(params Trivia[] values) {
			return (ChunkNode)base.AddTriviaList(values);
		}
		
		/// <summary>Adds the specified element from the TriviaList collection.</summary>
		public new ChunkNode AddTriviaList(Trivia value) {
			return (ChunkNode)base.AddTriviaList(value);
		}
		
		/// <summary>Removes the specified elements from the TriviaList collection.</summary>
		public new ChunkNode RemoveTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (ChunkNode)base.RemoveTriviaList(values);
		}
		
		/// <summary>Removes the specified elements from the TriviaList collection.</summary>
		public new ChunkNode RemoveTriviaList(params Trivia[] values) {
			return (ChunkNode)base.RemoveTriviaList(values);
		}
		
		/// <summary>Removes the specified element from the TriviaList collection.</summary>
		public new ChunkNode RemoveTriviaList(Trivia value) {
			return (ChunkNode)base.RemoveTriviaList(value);
		}
		
		/// <summary>Clears all elements from the TriviaList collection.</summary>
		public new ChunkNode RemoveTriviaList() {
			return (ChunkNode)base.RemoveTriviaList();
		}
		
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected override SyntaxNode WithCore(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>)) {
			return this.WithFactory(
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public ChunkNode With(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<Block> programBlock = default(ImmutableObjectGraph.Optional<Block>),
			ImmutableObjectGraph.Optional<EndOfFileNode> endOfFile = default(ImmutableObjectGraph.Optional<EndOfFileNode>)) {
			return (ChunkNode)this.WithCore(
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length,
				programBlock: programBlock,
				endOfFile: endOfFile);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected virtual ChunkNode WithCore(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<Block> programBlock = default(ImmutableObjectGraph.Optional<Block>),
			ImmutableObjectGraph.Optional<EndOfFileNode> endOfFile = default(ImmutableObjectGraph.Optional<EndOfFileNode>)) {
			var identity = default(ImmutableObjectGraph.Optional<System.UInt32>);
			return this.WithFactory(
				triviaList: Optional.For(triviaList.GetValueOrDefault(this.TriviaList)),
				fullStartPosition: Optional.For(fullStartPosition.GetValueOrDefault(this.FullStartPosition)),
				startPosition: Optional.For(startPosition.GetValueOrDefault(this.StartPosition)),
				length: Optional.For(length.GetValueOrDefault(this.Length)),
				programBlock: Optional.For(programBlock.GetValueOrDefault(this.ProgramBlock)),
				endOfFile: Optional.For(endOfFile.GetValueOrDefault(this.EndOfFile)),
				identity: Optional.For(identity.GetValueOrDefault(this.Identity)));
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		private ChunkNode WithFactory(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<Block> programBlock = default(ImmutableObjectGraph.Optional<Block>),
			ImmutableObjectGraph.Optional<EndOfFileNode> endOfFile = default(ImmutableObjectGraph.Optional<EndOfFileNode>),
			ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (
				(identity.IsDefined && identity.Value != this.Identity) || 
				(triviaList.IsDefined && triviaList.Value != this.TriviaList) || 
				(fullStartPosition.IsDefined && fullStartPosition.Value != this.FullStartPosition) || 
				(startPosition.IsDefined && startPosition.Value != this.StartPosition) || 
				(length.IsDefined && length.Value != this.Length) || 
				(programBlock.IsDefined && programBlock.Value != this.ProgramBlock) || 
				(endOfFile.IsDefined && endOfFile.Value != this.EndOfFile)) {
				return new ChunkNode(
					identity: identity.GetValueOrDefault(this.Identity),
					triviaList: triviaList.GetValueOrDefault(this.TriviaList),
					fullStartPosition: fullStartPosition.GetValueOrDefault(this.FullStartPosition),
					startPosition: startPosition.GetValueOrDefault(this.StartPosition),
					length: length.GetValueOrDefault(this.Length),
					programBlock: programBlock.GetValueOrDefault(this.ProgramBlock),
					endOfFile: endOfFile.GetValueOrDefault(this.EndOfFile));
			} else {
				return this;
			}
		}
	
		/// <summary>Normalizes and/or validates all properties on this object.</summary>
		/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
		partial void Validate();
	
		/// <summary>Provides defaults for fields.</summary>
		/// <param name="template">The struct to set default values on.</param>
		static partial void CreateDefaultTemplate(ref Template template);
	
		/// <summary>Returns a newly instantiated ChunkNode whose fields are initialized with default values.</summary>
		private static ChunkNode GetDefaultTemplate() {
			var template = new Template();
			CreateDefaultTemplate(ref template);
			return new ChunkNode(
				default(System.UInt32),
				template.TriviaList,
				template.FullStartPosition,
				template.StartPosition,
				template.Length,
				template.ProgramBlock,
				template.EndOfFile,
				skipValidation: true);
		}
	
		/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
		private struct Template {
			internal System.Collections.Immutable.ImmutableList<Trivia> TriviaList { get; set; }
	
			internal System.Int32 FullStartPosition { get; set; }
	
			internal System.Int32 StartPosition { get; set; }
	
			internal System.Int32 Length { get; set; }
	
			internal Block ProgramBlock { get; set; }
	
			internal EndOfFileNode EndOfFile { get; set; }
		}
		
		protected override SyntaxNodeChangedProperties DiffProperties(SyntaxNode other) {
			var propertiesChanged = base.DiffProperties(other);
		
			var otherChunkNode = other as ChunkNode;
			if (otherChunkNode != null) {
				if (this.ProgramBlock != otherChunkNode.ProgramBlock) {
					propertiesChanged |= SyntaxNodeChangedProperties.ProgramBlock;
				}
		
				if (this.EndOfFile != otherChunkNode.EndOfFile) {
					propertiesChanged |= SyntaxNodeChangedProperties.EndOfFile;
				}
			}
		
			return propertiesChanged;
		}
		
		internal static ChunkNode CreateWithIdentity(
				System.Collections.Immutable.ImmutableList<Trivia> triviaList,
				System.Int32 fullStartPosition,
				System.Int32 startPosition,
				System.Int32 length,
				ImmutableObjectGraph.Optional<Block> programBlock = default(ImmutableObjectGraph.Optional<Block>),
				ImmutableObjectGraph.Optional<EndOfFileNode> endOfFile = default(ImmutableObjectGraph.Optional<EndOfFileNode>),
				ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (!identity.IsDefined) {
				identity = NewIdentity();
			}
		
			return DefaultInstance.WithFactory(
					triviaList: Optional.For(triviaList),
					fullStartPosition: Optional.For(fullStartPosition),
					startPosition: Optional.For(startPosition),
					length: Optional.For(length),
					programBlock: Optional.For(programBlock.GetValueOrDefault(DefaultInstance.ProgramBlock)),
					endOfFile: Optional.For(endOfFile.GetValueOrDefault(DefaultInstance.EndOfFile)),
					identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
		
		public new Builder ToBuilder() {
			return new Builder(this);
		}
		
		public static new Builder CreateBuilder() {
			return new Builder(DefaultInstance);
		}
		
		public new partial class Builder : SyntaxNode.Builder {
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			private ChunkNode immutable;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected ImmutableObjectGraph.Optional<Block.Builder> programBlock;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected ImmutableObjectGraph.Optional<EndOfFileNode.Builder> endOfFile;
		
			internal Builder(ChunkNode immutable) : base(immutable) {
				this.immutable = immutable;
		
			}
		
			public Block.Builder ProgramBlock {
				get {
					if (!this.programBlock.IsDefined) {
						this.programBlock = this.immutable.programBlock != null ? this.immutable.programBlock.ToBuilder() : null;
					}
		
					return this.programBlock.Value;
				}
		
				set {
					this.programBlock = value;
				}
			}
		
			public EndOfFileNode.Builder EndOfFile {
				get {
					if (!this.endOfFile.IsDefined) {
						this.endOfFile = this.immutable.endOfFile != null ? this.immutable.endOfFile.ToBuilder() : null;
					}
		
					return this.endOfFile.Value;
				}
		
				set {
					this.endOfFile = value;
				}
			}
		
			public new ChunkNode ToImmutable() {
				var triviaList = this.triviaList.IsDefined ? (this.triviaList.Value != null ? this.triviaList.Value.ToImmutable() : null) : this.immutable.TriviaList;
				var programBlock = this.programBlock.IsDefined ? (this.programBlock.Value != null ? this.programBlock.Value.ToImmutable() : null) : this.immutable.ProgramBlock;
				var endOfFile = this.endOfFile.IsDefined ? (this.endOfFile.Value != null ? this.endOfFile.Value.ToImmutable() : null) : this.immutable.EndOfFile;
				return this.immutable = this.immutable.With(
					ImmutableObjectGraph.Optional.For(triviaList),
					ImmutableObjectGraph.Optional.For(this.FullStartPosition),
					ImmutableObjectGraph.Optional.For(this.StartPosition),
					ImmutableObjectGraph.Optional.For(this.Length),
					ImmutableObjectGraph.Optional.For(programBlock),
					ImmutableObjectGraph.Optional.For(endOfFile));
			}
		}
	}
	
	public partial class EndOfFileNode : SyntaxNode {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private static readonly EndOfFileNode DefaultInstance = GetDefaultTemplate();
	
		/// <summary>Initializes a new instance of the EndOfFileNode class.</summary>
		protected EndOfFileNode(
			System.UInt32 identity,
			System.Collections.Immutable.ImmutableList<Trivia> triviaList,
			System.Int32 fullStartPosition,
			System.Int32 startPosition,
			System.Int32 length,
			ImmutableObjectGraph.Optional<bool> skipValidation = default(ImmutableObjectGraph.Optional<bool>))
			: base(
				identity: identity,
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length)
		{
			if (!skipValidation.Value) {
				this.Validate();
			}
		}
	
		public static EndOfFileNode Create(
			System.Collections.Immutable.ImmutableList<Trivia> triviaList,
			System.Int32 fullStartPosition,
			System.Int32 startPosition,
			System.Int32 length) {
			var identity = Optional.For(NewIdentity());
			return DefaultInstance.WithFactory(
				triviaList: Optional.For(triviaList),
				fullStartPosition: Optional.For(fullStartPosition),
				startPosition: Optional.For(startPosition),
				length: Optional.For(length),
				identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
		
		/// <summary>Replaces the elements of the TriviaList collection with the specified collection.</summary>
		public new EndOfFileNode WithTriviaList(params Trivia[] values) {
			return (EndOfFileNode)base.WithTriviaList(values);
		}
		
		/// <summary>Replaces the elements of the TriviaList collection with the specified collection.</summary>
		public new EndOfFileNode WithTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (EndOfFileNode)base.WithTriviaList(values);
		}
		
		/// <summary>Adds the specified elements from the TriviaList collection.</summary>
		public new EndOfFileNode AddTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (EndOfFileNode)base.AddTriviaList(values);
		}
		
		/// <summary>Adds the specified elements from the TriviaList collection.</summary>
		public new EndOfFileNode AddTriviaList(params Trivia[] values) {
			return (EndOfFileNode)base.AddTriviaList(values);
		}
		
		/// <summary>Adds the specified element from the TriviaList collection.</summary>
		public new EndOfFileNode AddTriviaList(Trivia value) {
			return (EndOfFileNode)base.AddTriviaList(value);
		}
		
		/// <summary>Removes the specified elements from the TriviaList collection.</summary>
		public new EndOfFileNode RemoveTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (EndOfFileNode)base.RemoveTriviaList(values);
		}
		
		/// <summary>Removes the specified elements from the TriviaList collection.</summary>
		public new EndOfFileNode RemoveTriviaList(params Trivia[] values) {
			return (EndOfFileNode)base.RemoveTriviaList(values);
		}
		
		/// <summary>Removes the specified element from the TriviaList collection.</summary>
		public new EndOfFileNode RemoveTriviaList(Trivia value) {
			return (EndOfFileNode)base.RemoveTriviaList(value);
		}
		
		/// <summary>Clears all elements from the TriviaList collection.</summary>
		public new EndOfFileNode RemoveTriviaList() {
			return (EndOfFileNode)base.RemoveTriviaList();
		}
		
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected override SyntaxNode WithCore(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>)) {
			return this.WithFactory(
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public EndOfFileNode With(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>)) {
			return (EndOfFileNode)this.WithCore(
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		private EndOfFileNode WithFactory(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (
				(identity.IsDefined && identity.Value != this.Identity) || 
				(triviaList.IsDefined && triviaList.Value != this.TriviaList) || 
				(fullStartPosition.IsDefined && fullStartPosition.Value != this.FullStartPosition) || 
				(startPosition.IsDefined && startPosition.Value != this.StartPosition) || 
				(length.IsDefined && length.Value != this.Length)) {
				return new EndOfFileNode(
					identity: identity.GetValueOrDefault(this.Identity),
					triviaList: triviaList.GetValueOrDefault(this.TriviaList),
					fullStartPosition: fullStartPosition.GetValueOrDefault(this.FullStartPosition),
					startPosition: startPosition.GetValueOrDefault(this.StartPosition),
					length: length.GetValueOrDefault(this.Length));
			} else {
				return this;
			}
		}
	
		/// <summary>Normalizes and/or validates all properties on this object.</summary>
		/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
		partial void Validate();
	
		/// <summary>Provides defaults for fields.</summary>
		/// <param name="template">The struct to set default values on.</param>
		static partial void CreateDefaultTemplate(ref Template template);
	
		/// <summary>Returns a newly instantiated EndOfFileNode whose fields are initialized with default values.</summary>
		private static EndOfFileNode GetDefaultTemplate() {
			var template = new Template();
			CreateDefaultTemplate(ref template);
			return new EndOfFileNode(
				default(System.UInt32),
				template.TriviaList,
				template.FullStartPosition,
				template.StartPosition,
				template.Length,
				skipValidation: true);
		}
	
		/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
		private struct Template {
			internal System.Collections.Immutable.ImmutableList<Trivia> TriviaList { get; set; }
	
			internal System.Int32 FullStartPosition { get; set; }
	
			internal System.Int32 StartPosition { get; set; }
	
			internal System.Int32 Length { get; set; }
		}
		
		internal static EndOfFileNode CreateWithIdentity(
				System.Collections.Immutable.ImmutableList<Trivia> triviaList,
				System.Int32 fullStartPosition,
				System.Int32 startPosition,
				System.Int32 length,
				ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (!identity.IsDefined) {
				identity = NewIdentity();
			}
		
			return DefaultInstance;
		}
		
		public new Builder ToBuilder() {
			return new Builder(this);
		}
		
		public static new Builder CreateBuilder() {
			return new Builder(DefaultInstance);
		}
		
		public new partial class Builder : SyntaxNode.Builder {
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			private EndOfFileNode immutable;
		
			internal Builder(EndOfFileNode immutable) : base(immutable) {
				this.immutable = immutable;
		
			}
		
			public new EndOfFileNode ToImmutable() {
				var triviaList = this.triviaList.IsDefined ? (this.triviaList.Value != null ? this.triviaList.Value.ToImmutable() : null) : this.immutable.TriviaList;
				return this.immutable = this.immutable;
			}
		}
	}
	
	public partial class IfNode : SyntaxNode {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private static readonly IfNode DefaultInstance = GetDefaultTemplate();
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly Keyword ifKeyword;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly Expression exp;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly Keyword thenKeyword;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly Block ifBlock;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.Collections.Immutable.ImmutableList<ElseIfBlock> elseIfList;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly ElseBlock elseBlock;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly Keyword endKeyword;
	
		/// <summary>Initializes a new instance of the IfNode class.</summary>
		protected IfNode(
			System.UInt32 identity,
			System.Collections.Immutable.ImmutableList<Trivia> triviaList,
			System.Int32 fullStartPosition,
			System.Int32 startPosition,
			System.Int32 length,
			Keyword ifKeyword,
			Expression exp,
			Keyword thenKeyword,
			Block ifBlock,
			System.Collections.Immutable.ImmutableList<ElseIfBlock> elseIfList,
			ElseBlock elseBlock,
			Keyword endKeyword,
			ImmutableObjectGraph.Optional<bool> skipValidation = default(ImmutableObjectGraph.Optional<bool>))
			: base(
				identity: identity,
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length)
		{
			this.ifKeyword = ifKeyword;
			this.exp = exp;
			this.thenKeyword = thenKeyword;
			this.ifBlock = ifBlock;
			this.elseIfList = elseIfList;
			this.elseBlock = elseBlock;
			this.endKeyword = endKeyword;
			if (!skipValidation.Value) {
				this.Validate();
			}
		}
	
		public static IfNode Create(
			System.Collections.Immutable.ImmutableList<Trivia> triviaList,
			System.Int32 fullStartPosition,
			System.Int32 startPosition,
			System.Int32 length,
			ImmutableObjectGraph.Optional<Keyword> ifKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Expression> exp = default(ImmutableObjectGraph.Optional<Expression>),
			ImmutableObjectGraph.Optional<Keyword> thenKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Block> ifBlock = default(ImmutableObjectGraph.Optional<Block>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<ElseIfBlock>> elseIfList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<ElseIfBlock>>),
			ImmutableObjectGraph.Optional<ElseBlock> elseBlock = default(ImmutableObjectGraph.Optional<ElseBlock>),
			ImmutableObjectGraph.Optional<Keyword> endKeyword = default(ImmutableObjectGraph.Optional<Keyword>)) {
			var identity = Optional.For(NewIdentity());
			return DefaultInstance.WithFactory(
				triviaList: Optional.For(triviaList),
				fullStartPosition: Optional.For(fullStartPosition),
				startPosition: Optional.For(startPosition),
				length: Optional.For(length),
				ifKeyword: Optional.For(ifKeyword.GetValueOrDefault(DefaultInstance.IfKeyword)),
				exp: Optional.For(exp.GetValueOrDefault(DefaultInstance.Exp)),
				thenKeyword: Optional.For(thenKeyword.GetValueOrDefault(DefaultInstance.ThenKeyword)),
				ifBlock: Optional.For(ifBlock.GetValueOrDefault(DefaultInstance.IfBlock)),
				elseIfList: Optional.For(elseIfList.GetValueOrDefault(DefaultInstance.ElseIfList)),
				elseBlock: Optional.For(elseBlock.GetValueOrDefault(DefaultInstance.ElseBlock)),
				endKeyword: Optional.For(endKeyword.GetValueOrDefault(DefaultInstance.EndKeyword)),
				identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
	
		public Keyword IfKeyword {
			get { return this.ifKeyword; }
		}
	
		public Expression Exp {
			get { return this.exp; }
		}
	
		public Keyword ThenKeyword {
			get { return this.thenKeyword; }
		}
	
		public Block IfBlock {
			get { return this.ifBlock; }
		}
	
		public System.Collections.Immutable.ImmutableList<ElseIfBlock> ElseIfList {
			get { return this.elseIfList; }
		}
	
		public ElseBlock ElseBlock {
			get { return this.elseBlock; }
		}
	
		public Keyword EndKeyword {
			get { return this.endKeyword; }
		}
		
		/// <summary>Replaces the elements of the TriviaList collection with the specified collection.</summary>
		public new IfNode WithTriviaList(params Trivia[] values) {
			return (IfNode)base.WithTriviaList(values);
		}
		
		/// <summary>Replaces the elements of the TriviaList collection with the specified collection.</summary>
		public new IfNode WithTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (IfNode)base.WithTriviaList(values);
		}
		
		/// <summary>Adds the specified elements from the TriviaList collection.</summary>
		public new IfNode AddTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (IfNode)base.AddTriviaList(values);
		}
		
		/// <summary>Adds the specified elements from the TriviaList collection.</summary>
		public new IfNode AddTriviaList(params Trivia[] values) {
			return (IfNode)base.AddTriviaList(values);
		}
		
		/// <summary>Adds the specified element from the TriviaList collection.</summary>
		public new IfNode AddTriviaList(Trivia value) {
			return (IfNode)base.AddTriviaList(value);
		}
		
		/// <summary>Removes the specified elements from the TriviaList collection.</summary>
		public new IfNode RemoveTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (IfNode)base.RemoveTriviaList(values);
		}
		
		/// <summary>Removes the specified elements from the TriviaList collection.</summary>
		public new IfNode RemoveTriviaList(params Trivia[] values) {
			return (IfNode)base.RemoveTriviaList(values);
		}
		
		/// <summary>Removes the specified element from the TriviaList collection.</summary>
		public new IfNode RemoveTriviaList(Trivia value) {
			return (IfNode)base.RemoveTriviaList(value);
		}
		
		/// <summary>Clears all elements from the TriviaList collection.</summary>
		public new IfNode RemoveTriviaList() {
			return (IfNode)base.RemoveTriviaList();
		}
		
		
		/// <summary>Replaces the elements of the ElseIfList collection with the specified collection.</summary>
		public IfNode WithElseIfList(params ElseIfBlock[] values) {
			return this.With(elseIfList: this.ElseIfList.ResetContents(values));
		}
		
		/// <summary>Replaces the elements of the ElseIfList collection with the specified collection.</summary>
		public IfNode WithElseIfList(System.Collections.Generic.IEnumerable<ElseIfBlock> values) {
			return this.With(elseIfList: this.ElseIfList.ResetContents(values));
		}
		
		/// <summary>Adds the specified elements from the ElseIfList collection.</summary>
		public IfNode AddElseIfList(System.Collections.Generic.IEnumerable<ElseIfBlock> values) {
			return this.With(elseIfList: this.ElseIfList.AddRange(values));
		}
		
		/// <summary>Adds the specified elements from the ElseIfList collection.</summary>
		public IfNode AddElseIfList(params ElseIfBlock[] values) {
			return this.With(elseIfList: this.ElseIfList.AddRange(values));
		}
		
		/// <summary>Adds the specified element from the ElseIfList collection.</summary>
		public IfNode AddElseIfList(ElseIfBlock value) {
			return this.With(elseIfList: this.ElseIfList.Add(value));
		}
		
		/// <summary>Removes the specified elements from the ElseIfList collection.</summary>
		public IfNode RemoveElseIfList(System.Collections.Generic.IEnumerable<ElseIfBlock> values) {
			return this.With(elseIfList: this.ElseIfList.RemoveRange(values));
		}
		
		/// <summary>Removes the specified elements from the ElseIfList collection.</summary>
		public IfNode RemoveElseIfList(params ElseIfBlock[] values) {
			return this.With(elseIfList: this.ElseIfList.RemoveRange(values));
		}
		
		/// <summary>Removes the specified element from the ElseIfList collection.</summary>
		public IfNode RemoveElseIfList(ElseIfBlock value) {
			return this.With(elseIfList: this.ElseIfList.Remove(value));
		}
		
		/// <summary>Clears all elements from the ElseIfList collection.</summary>
		public IfNode RemoveElseIfList() {
			return this.With(elseIfList: this.ElseIfList.Clear());
		}
		
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected override SyntaxNode WithCore(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>)) {
			return this.WithFactory(
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public IfNode With(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<Keyword> ifKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Expression> exp = default(ImmutableObjectGraph.Optional<Expression>),
			ImmutableObjectGraph.Optional<Keyword> thenKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Block> ifBlock = default(ImmutableObjectGraph.Optional<Block>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<ElseIfBlock>> elseIfList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<ElseIfBlock>>),
			ImmutableObjectGraph.Optional<ElseBlock> elseBlock = default(ImmutableObjectGraph.Optional<ElseBlock>),
			ImmutableObjectGraph.Optional<Keyword> endKeyword = default(ImmutableObjectGraph.Optional<Keyword>)) {
			return (IfNode)this.WithCore(
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length,
				ifKeyword: ifKeyword,
				exp: exp,
				thenKeyword: thenKeyword,
				ifBlock: ifBlock,
				elseIfList: elseIfList,
				elseBlock: elseBlock,
				endKeyword: endKeyword);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected virtual IfNode WithCore(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<Keyword> ifKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Expression> exp = default(ImmutableObjectGraph.Optional<Expression>),
			ImmutableObjectGraph.Optional<Keyword> thenKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Block> ifBlock = default(ImmutableObjectGraph.Optional<Block>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<ElseIfBlock>> elseIfList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<ElseIfBlock>>),
			ImmutableObjectGraph.Optional<ElseBlock> elseBlock = default(ImmutableObjectGraph.Optional<ElseBlock>),
			ImmutableObjectGraph.Optional<Keyword> endKeyword = default(ImmutableObjectGraph.Optional<Keyword>)) {
			var identity = default(ImmutableObjectGraph.Optional<System.UInt32>);
			return this.WithFactory(
				triviaList: Optional.For(triviaList.GetValueOrDefault(this.TriviaList)),
				fullStartPosition: Optional.For(fullStartPosition.GetValueOrDefault(this.FullStartPosition)),
				startPosition: Optional.For(startPosition.GetValueOrDefault(this.StartPosition)),
				length: Optional.For(length.GetValueOrDefault(this.Length)),
				ifKeyword: Optional.For(ifKeyword.GetValueOrDefault(this.IfKeyword)),
				exp: Optional.For(exp.GetValueOrDefault(this.Exp)),
				thenKeyword: Optional.For(thenKeyword.GetValueOrDefault(this.ThenKeyword)),
				ifBlock: Optional.For(ifBlock.GetValueOrDefault(this.IfBlock)),
				elseIfList: Optional.For(elseIfList.GetValueOrDefault(this.ElseIfList)),
				elseBlock: Optional.For(elseBlock.GetValueOrDefault(this.ElseBlock)),
				endKeyword: Optional.For(endKeyword.GetValueOrDefault(this.EndKeyword)),
				identity: Optional.For(identity.GetValueOrDefault(this.Identity)));
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		private IfNode WithFactory(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<Keyword> ifKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Expression> exp = default(ImmutableObjectGraph.Optional<Expression>),
			ImmutableObjectGraph.Optional<Keyword> thenKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<Block> ifBlock = default(ImmutableObjectGraph.Optional<Block>),
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<ElseIfBlock>> elseIfList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<ElseIfBlock>>),
			ImmutableObjectGraph.Optional<ElseBlock> elseBlock = default(ImmutableObjectGraph.Optional<ElseBlock>),
			ImmutableObjectGraph.Optional<Keyword> endKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
			ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (
				(identity.IsDefined && identity.Value != this.Identity) || 
				(triviaList.IsDefined && triviaList.Value != this.TriviaList) || 
				(fullStartPosition.IsDefined && fullStartPosition.Value != this.FullStartPosition) || 
				(startPosition.IsDefined && startPosition.Value != this.StartPosition) || 
				(length.IsDefined && length.Value != this.Length) || 
				(ifKeyword.IsDefined && ifKeyword.Value != this.IfKeyword) || 
				(exp.IsDefined && exp.Value != this.Exp) || 
				(thenKeyword.IsDefined && thenKeyword.Value != this.ThenKeyword) || 
				(ifBlock.IsDefined && ifBlock.Value != this.IfBlock) || 
				(elseIfList.IsDefined && elseIfList.Value != this.ElseIfList) || 
				(elseBlock.IsDefined && elseBlock.Value != this.ElseBlock) || 
				(endKeyword.IsDefined && endKeyword.Value != this.EndKeyword)) {
				return new IfNode(
					identity: identity.GetValueOrDefault(this.Identity),
					triviaList: triviaList.GetValueOrDefault(this.TriviaList),
					fullStartPosition: fullStartPosition.GetValueOrDefault(this.FullStartPosition),
					startPosition: startPosition.GetValueOrDefault(this.StartPosition),
					length: length.GetValueOrDefault(this.Length),
					ifKeyword: ifKeyword.GetValueOrDefault(this.IfKeyword),
					exp: exp.GetValueOrDefault(this.Exp),
					thenKeyword: thenKeyword.GetValueOrDefault(this.ThenKeyword),
					ifBlock: ifBlock.GetValueOrDefault(this.IfBlock),
					elseIfList: elseIfList.GetValueOrDefault(this.ElseIfList),
					elseBlock: elseBlock.GetValueOrDefault(this.ElseBlock),
					endKeyword: endKeyword.GetValueOrDefault(this.EndKeyword));
			} else {
				return this;
			}
		}
	
		/// <summary>Normalizes and/or validates all properties on this object.</summary>
		/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
		partial void Validate();
	
		/// <summary>Provides defaults for fields.</summary>
		/// <param name="template">The struct to set default values on.</param>
		static partial void CreateDefaultTemplate(ref Template template);
	
		/// <summary>Returns a newly instantiated IfNode whose fields are initialized with default values.</summary>
		private static IfNode GetDefaultTemplate() {
			var template = new Template();
			CreateDefaultTemplate(ref template);
			return new IfNode(
				default(System.UInt32),
				template.TriviaList,
				template.FullStartPosition,
				template.StartPosition,
				template.Length,
				template.IfKeyword,
				template.Exp,
				template.ThenKeyword,
				template.IfBlock,
				template.ElseIfList,
				template.ElseBlock,
				template.EndKeyword,
				skipValidation: true);
		}
	
		/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
		private struct Template {
			internal System.Collections.Immutable.ImmutableList<Trivia> TriviaList { get; set; }
	
			internal System.Int32 FullStartPosition { get; set; }
	
			internal System.Int32 StartPosition { get; set; }
	
			internal System.Int32 Length { get; set; }
	
			internal Keyword IfKeyword { get; set; }
	
			internal Expression Exp { get; set; }
	
			internal Keyword ThenKeyword { get; set; }
	
			internal Block IfBlock { get; set; }
	
			internal System.Collections.Immutable.ImmutableList<ElseIfBlock> ElseIfList { get; set; }
	
			internal ElseBlock ElseBlock { get; set; }
	
			internal Keyword EndKeyword { get; set; }
		}
		
		protected override SyntaxNodeChangedProperties DiffProperties(SyntaxNode other) {
			var propertiesChanged = base.DiffProperties(other);
		
			var otherIfNode = other as IfNode;
			if (otherIfNode != null) {
				if (this.IfKeyword != otherIfNode.IfKeyword) {
					propertiesChanged |= SyntaxNodeChangedProperties.IfKeyword;
				}
		
				if (this.Exp != otherIfNode.Exp) {
					propertiesChanged |= SyntaxNodeChangedProperties.Exp;
				}
		
				if (this.ThenKeyword != otherIfNode.ThenKeyword) {
					propertiesChanged |= SyntaxNodeChangedProperties.ThenKeyword;
				}
		
				if (this.IfBlock != otherIfNode.IfBlock) {
					propertiesChanged |= SyntaxNodeChangedProperties.IfBlock;
				}
		
				if (this.ElseIfList != otherIfNode.ElseIfList) {
					propertiesChanged |= SyntaxNodeChangedProperties.ElseIfList;
				}
		
				if (this.ElseBlock != otherIfNode.ElseBlock) {
					propertiesChanged |= SyntaxNodeChangedProperties.ElseBlock;
				}
		
				if (this.EndKeyword != otherIfNode.EndKeyword) {
					propertiesChanged |= SyntaxNodeChangedProperties.EndKeyword;
				}
			}
		
			return propertiesChanged;
		}
		
		internal static IfNode CreateWithIdentity(
				System.Collections.Immutable.ImmutableList<Trivia> triviaList,
				System.Int32 fullStartPosition,
				System.Int32 startPosition,
				System.Int32 length,
				ImmutableObjectGraph.Optional<Keyword> ifKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
				ImmutableObjectGraph.Optional<Expression> exp = default(ImmutableObjectGraph.Optional<Expression>),
				ImmutableObjectGraph.Optional<Keyword> thenKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
				ImmutableObjectGraph.Optional<Block> ifBlock = default(ImmutableObjectGraph.Optional<Block>),
				ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<ElseIfBlock>> elseIfList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<ElseIfBlock>>),
				ImmutableObjectGraph.Optional<ElseBlock> elseBlock = default(ImmutableObjectGraph.Optional<ElseBlock>),
				ImmutableObjectGraph.Optional<Keyword> endKeyword = default(ImmutableObjectGraph.Optional<Keyword>),
				ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (!identity.IsDefined) {
				identity = NewIdentity();
			}
		
			return DefaultInstance.WithFactory(
					triviaList: Optional.For(triviaList),
					fullStartPosition: Optional.For(fullStartPosition),
					startPosition: Optional.For(startPosition),
					length: Optional.For(length),
					ifKeyword: Optional.For(ifKeyword.GetValueOrDefault(DefaultInstance.IfKeyword)),
					exp: Optional.For(exp.GetValueOrDefault(DefaultInstance.Exp)),
					thenKeyword: Optional.For(thenKeyword.GetValueOrDefault(DefaultInstance.ThenKeyword)),
					ifBlock: Optional.For(ifBlock.GetValueOrDefault(DefaultInstance.IfBlock)),
					elseIfList: Optional.For(elseIfList.GetValueOrDefault(DefaultInstance.ElseIfList)),
					elseBlock: Optional.For(elseBlock.GetValueOrDefault(DefaultInstance.ElseBlock)),
					endKeyword: Optional.For(endKeyword.GetValueOrDefault(DefaultInstance.EndKeyword)),
					identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
		
		public new Builder ToBuilder() {
			return new Builder(this);
		}
		
		public static new Builder CreateBuilder() {
			return new Builder(DefaultInstance);
		}
		
		public new partial class Builder : SyntaxNode.Builder {
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			private IfNode immutable;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected ImmutableObjectGraph.Optional<Keyword.Builder> ifKeyword;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected ImmutableObjectGraph.Optional<Expression.Builder> exp;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected ImmutableObjectGraph.Optional<Keyword.Builder> thenKeyword;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected ImmutableObjectGraph.Optional<Block.Builder> ifBlock;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<ElseIfBlock>.Builder> elseIfList;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected ImmutableObjectGraph.Optional<ElseBlock.Builder> elseBlock;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected ImmutableObjectGraph.Optional<Keyword.Builder> endKeyword;
		
			internal Builder(IfNode immutable) : base(immutable) {
				this.immutable = immutable;
		
			}
		
			public Keyword.Builder IfKeyword {
				get {
					if (!this.ifKeyword.IsDefined) {
						this.ifKeyword = this.immutable.ifKeyword != null ? this.immutable.ifKeyword.ToBuilder() : null;
					}
		
					return this.ifKeyword.Value;
				}
		
				set {
					this.ifKeyword = value;
				}
			}
		
			public Expression.Builder Exp {
				get {
					if (!this.exp.IsDefined) {
						this.exp = this.immutable.exp != null ? this.immutable.exp.ToBuilder() : null;
					}
		
					return this.exp.Value;
				}
		
				set {
					this.exp = value;
				}
			}
		
			public Keyword.Builder ThenKeyword {
				get {
					if (!this.thenKeyword.IsDefined) {
						this.thenKeyword = this.immutable.thenKeyword != null ? this.immutable.thenKeyword.ToBuilder() : null;
					}
		
					return this.thenKeyword.Value;
				}
		
				set {
					this.thenKeyword = value;
				}
			}
		
			public Block.Builder IfBlock {
				get {
					if (!this.ifBlock.IsDefined) {
						this.ifBlock = this.immutable.ifBlock != null ? this.immutable.ifBlock.ToBuilder() : null;
					}
		
					return this.ifBlock.Value;
				}
		
				set {
					this.ifBlock = value;
				}
			}
		
			public System.Collections.Immutable.ImmutableList<ElseIfBlock>.Builder ElseIfList {
				get {
					if (!this.elseIfList.IsDefined) {
						this.elseIfList = this.immutable.elseIfList != null ? this.immutable.elseIfList.ToBuilder() : null;
					}
		
					return this.elseIfList.Value;
				}
		
				set {
					this.elseIfList = value;
				}
			}
		
			public ElseBlock.Builder ElseBlock {
				get {
					if (!this.elseBlock.IsDefined) {
						this.elseBlock = this.immutable.elseBlock != null ? this.immutable.elseBlock.ToBuilder() : null;
					}
		
					return this.elseBlock.Value;
				}
		
				set {
					this.elseBlock = value;
				}
			}
		
			public Keyword.Builder EndKeyword {
				get {
					if (!this.endKeyword.IsDefined) {
						this.endKeyword = this.immutable.endKeyword != null ? this.immutable.endKeyword.ToBuilder() : null;
					}
		
					return this.endKeyword.Value;
				}
		
				set {
					this.endKeyword = value;
				}
			}
		
			public new IfNode ToImmutable() {
				var triviaList = this.triviaList.IsDefined ? (this.triviaList.Value != null ? this.triviaList.Value.ToImmutable() : null) : this.immutable.TriviaList;
				var ifKeyword = this.ifKeyword.IsDefined ? (this.ifKeyword.Value != null ? this.ifKeyword.Value.ToImmutable() : null) : this.immutable.IfKeyword;
				var exp = this.exp.IsDefined ? (this.exp.Value != null ? this.exp.Value.ToImmutable() : null) : this.immutable.Exp;
				var thenKeyword = this.thenKeyword.IsDefined ? (this.thenKeyword.Value != null ? this.thenKeyword.Value.ToImmutable() : null) : this.immutable.ThenKeyword;
				var ifBlock = this.ifBlock.IsDefined ? (this.ifBlock.Value != null ? this.ifBlock.Value.ToImmutable() : null) : this.immutable.IfBlock;
				var elseIfList = this.elseIfList.IsDefined ? (this.elseIfList.Value != null ? this.elseIfList.Value.ToImmutable() : null) : this.immutable.ElseIfList;
				var elseBlock = this.elseBlock.IsDefined ? (this.elseBlock.Value != null ? this.elseBlock.Value.ToImmutable() : null) : this.immutable.ElseBlock;
				var endKeyword = this.endKeyword.IsDefined ? (this.endKeyword.Value != null ? this.endKeyword.Value.ToImmutable() : null) : this.immutable.EndKeyword;
				return this.immutable = this.immutable.With(
					ImmutableObjectGraph.Optional.For(triviaList),
					ImmutableObjectGraph.Optional.For(this.FullStartPosition),
					ImmutableObjectGraph.Optional.For(this.StartPosition),
					ImmutableObjectGraph.Optional.For(this.Length),
					ImmutableObjectGraph.Optional.For(ifKeyword),
					ImmutableObjectGraph.Optional.For(exp),
					ImmutableObjectGraph.Optional.For(thenKeyword),
					ImmutableObjectGraph.Optional.For(ifBlock),
					ImmutableObjectGraph.Optional.For(elseIfList),
					ImmutableObjectGraph.Optional.For(elseBlock),
					ImmutableObjectGraph.Optional.For(endKeyword));
			}
		}
	}
	
	public partial class Expression : SyntaxNode {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private static readonly Expression DefaultInstance = GetDefaultTemplate();
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly KeyValue keyvalue;
	
		/// <summary>Initializes a new instance of the Expression class.</summary>
		protected Expression(
			System.UInt32 identity,
			System.Collections.Immutable.ImmutableList<Trivia> triviaList,
			System.Int32 fullStartPosition,
			System.Int32 startPosition,
			System.Int32 length,
			KeyValue keyvalue,
			ImmutableObjectGraph.Optional<bool> skipValidation = default(ImmutableObjectGraph.Optional<bool>))
			: base(
				identity: identity,
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length)
		{
			this.keyvalue = keyvalue;
			if (!skipValidation.Value) {
				this.Validate();
			}
		}
	
		public static Expression Create(
			System.Collections.Immutable.ImmutableList<Trivia> triviaList,
			System.Int32 fullStartPosition,
			System.Int32 startPosition,
			System.Int32 length,
			ImmutableObjectGraph.Optional<KeyValue> keyvalue = default(ImmutableObjectGraph.Optional<KeyValue>)) {
			var identity = Optional.For(NewIdentity());
			return DefaultInstance.WithFactory(
				triviaList: Optional.For(triviaList),
				fullStartPosition: Optional.For(fullStartPosition),
				startPosition: Optional.For(startPosition),
				length: Optional.For(length),
				keyvalue: Optional.For(keyvalue.GetValueOrDefault(DefaultInstance.Keyvalue)),
				identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
	
		public KeyValue Keyvalue {
			get { return this.keyvalue; }
		}
		
		/// <summary>Replaces the elements of the TriviaList collection with the specified collection.</summary>
		public new Expression WithTriviaList(params Trivia[] values) {
			return (Expression)base.WithTriviaList(values);
		}
		
		/// <summary>Replaces the elements of the TriviaList collection with the specified collection.</summary>
		public new Expression WithTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (Expression)base.WithTriviaList(values);
		}
		
		/// <summary>Adds the specified elements from the TriviaList collection.</summary>
		public new Expression AddTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (Expression)base.AddTriviaList(values);
		}
		
		/// <summary>Adds the specified elements from the TriviaList collection.</summary>
		public new Expression AddTriviaList(params Trivia[] values) {
			return (Expression)base.AddTriviaList(values);
		}
		
		/// <summary>Adds the specified element from the TriviaList collection.</summary>
		public new Expression AddTriviaList(Trivia value) {
			return (Expression)base.AddTriviaList(value);
		}
		
		/// <summary>Removes the specified elements from the TriviaList collection.</summary>
		public new Expression RemoveTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (Expression)base.RemoveTriviaList(values);
		}
		
		/// <summary>Removes the specified elements from the TriviaList collection.</summary>
		public new Expression RemoveTriviaList(params Trivia[] values) {
			return (Expression)base.RemoveTriviaList(values);
		}
		
		/// <summary>Removes the specified element from the TriviaList collection.</summary>
		public new Expression RemoveTriviaList(Trivia value) {
			return (Expression)base.RemoveTriviaList(value);
		}
		
		/// <summary>Clears all elements from the TriviaList collection.</summary>
		public new Expression RemoveTriviaList() {
			return (Expression)base.RemoveTriviaList();
		}
		
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected override SyntaxNode WithCore(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>)) {
			return this.WithFactory(
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public Expression With(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<KeyValue> keyvalue = default(ImmutableObjectGraph.Optional<KeyValue>)) {
			return (Expression)this.WithCore(
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length,
				keyvalue: keyvalue);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected virtual Expression WithCore(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<KeyValue> keyvalue = default(ImmutableObjectGraph.Optional<KeyValue>)) {
			var identity = default(ImmutableObjectGraph.Optional<System.UInt32>);
			return this.WithFactory(
				triviaList: Optional.For(triviaList.GetValueOrDefault(this.TriviaList)),
				fullStartPosition: Optional.For(fullStartPosition.GetValueOrDefault(this.FullStartPosition)),
				startPosition: Optional.For(startPosition.GetValueOrDefault(this.StartPosition)),
				length: Optional.For(length.GetValueOrDefault(this.Length)),
				keyvalue: Optional.For(keyvalue.GetValueOrDefault(this.Keyvalue)),
				identity: Optional.For(identity.GetValueOrDefault(this.Identity)));
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		private Expression WithFactory(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<KeyValue> keyvalue = default(ImmutableObjectGraph.Optional<KeyValue>),
			ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (
				(identity.IsDefined && identity.Value != this.Identity) || 
				(triviaList.IsDefined && triviaList.Value != this.TriviaList) || 
				(fullStartPosition.IsDefined && fullStartPosition.Value != this.FullStartPosition) || 
				(startPosition.IsDefined && startPosition.Value != this.StartPosition) || 
				(length.IsDefined && length.Value != this.Length) || 
				(keyvalue.IsDefined && keyvalue.Value != this.Keyvalue)) {
				return new Expression(
					identity: identity.GetValueOrDefault(this.Identity),
					triviaList: triviaList.GetValueOrDefault(this.TriviaList),
					fullStartPosition: fullStartPosition.GetValueOrDefault(this.FullStartPosition),
					startPosition: startPosition.GetValueOrDefault(this.StartPosition),
					length: length.GetValueOrDefault(this.Length),
					keyvalue: keyvalue.GetValueOrDefault(this.Keyvalue));
			} else {
				return this;
			}
		}
	
		/// <summary>Normalizes and/or validates all properties on this object.</summary>
		/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
		partial void Validate();
	
		/// <summary>Provides defaults for fields.</summary>
		/// <param name="template">The struct to set default values on.</param>
		static partial void CreateDefaultTemplate(ref Template template);
	
		/// <summary>Returns a newly instantiated Expression whose fields are initialized with default values.</summary>
		private static Expression GetDefaultTemplate() {
			var template = new Template();
			CreateDefaultTemplate(ref template);
			return new Expression(
				default(System.UInt32),
				template.TriviaList,
				template.FullStartPosition,
				template.StartPosition,
				template.Length,
				template.Keyvalue,
				skipValidation: true);
		}
	
		/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
		private struct Template {
			internal System.Collections.Immutable.ImmutableList<Trivia> TriviaList { get; set; }
	
			internal System.Int32 FullStartPosition { get; set; }
	
			internal System.Int32 StartPosition { get; set; }
	
			internal System.Int32 Length { get; set; }
	
			internal KeyValue Keyvalue { get; set; }
		}
		
		protected override SyntaxNodeChangedProperties DiffProperties(SyntaxNode other) {
			var propertiesChanged = base.DiffProperties(other);
		
			var otherExpression = other as Expression;
			if (otherExpression != null) {
				if (this.Keyvalue != otherExpression.Keyvalue) {
					propertiesChanged |= SyntaxNodeChangedProperties.Keyvalue;
				}
			}
		
			return propertiesChanged;
		}
		
		internal static Expression CreateWithIdentity(
				System.Collections.Immutable.ImmutableList<Trivia> triviaList,
				System.Int32 fullStartPosition,
				System.Int32 startPosition,
				System.Int32 length,
				ImmutableObjectGraph.Optional<KeyValue> keyvalue = default(ImmutableObjectGraph.Optional<KeyValue>),
				ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (!identity.IsDefined) {
				identity = NewIdentity();
			}
		
			return DefaultInstance.WithFactory(
					triviaList: Optional.For(triviaList),
					fullStartPosition: Optional.For(fullStartPosition),
					startPosition: Optional.For(startPosition),
					length: Optional.For(length),
					keyvalue: Optional.For(keyvalue.GetValueOrDefault(DefaultInstance.Keyvalue)),
					identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
		
		public new Builder ToBuilder() {
			return new Builder(this);
		}
		
		public static new Builder CreateBuilder() {
			return new Builder(DefaultInstance);
		}
		
		public new partial class Builder : SyntaxNode.Builder {
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			private Expression immutable;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected ImmutableObjectGraph.Optional<KeyValue.Builder> keyvalue;
		
			internal Builder(Expression immutable) : base(immutable) {
				this.immutable = immutable;
		
			}
		
			public KeyValue.Builder Keyvalue {
				get {
					if (!this.keyvalue.IsDefined) {
						this.keyvalue = this.immutable.keyvalue != null ? this.immutable.keyvalue.ToBuilder() : null;
					}
		
					return this.keyvalue.Value;
				}
		
				set {
					this.keyvalue = value;
				}
			}
		
			public new Expression ToImmutable() {
				var triviaList = this.triviaList.IsDefined ? (this.triviaList.Value != null ? this.triviaList.Value.ToImmutable() : null) : this.immutable.TriviaList;
				var keyvalue = this.keyvalue.IsDefined ? (this.keyvalue.Value != null ? this.keyvalue.Value.ToImmutable() : null) : this.immutable.Keyvalue;
				return this.immutable = this.immutable.With(
					ImmutableObjectGraph.Optional.For(triviaList),
					ImmutableObjectGraph.Optional.For(this.FullStartPosition),
					ImmutableObjectGraph.Optional.For(this.StartPosition),
					ImmutableObjectGraph.Optional.For(this.Length),
					ImmutableObjectGraph.Optional.For(keyvalue));
			}
		}
	}
	
	public partial class KeyValue : SyntaxNode {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private static readonly KeyValue DefaultInstance = GetDefaultTemplate();
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.String value;
	
		/// <summary>Initializes a new instance of the KeyValue class.</summary>
		protected KeyValue(
			System.UInt32 identity,
			System.Collections.Immutable.ImmutableList<Trivia> triviaList,
			System.Int32 fullStartPosition,
			System.Int32 startPosition,
			System.Int32 length,
			System.String value,
			ImmutableObjectGraph.Optional<bool> skipValidation = default(ImmutableObjectGraph.Optional<bool>))
			: base(
				identity: identity,
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length)
		{
			this.value = value;
			if (!skipValidation.Value) {
				this.Validate();
			}
		}
	
		public static KeyValue Create(
			System.Collections.Immutable.ImmutableList<Trivia> triviaList,
			System.Int32 fullStartPosition,
			System.Int32 startPosition,
			System.Int32 length,
			ImmutableObjectGraph.Optional<System.String> value = default(ImmutableObjectGraph.Optional<System.String>)) {
			var identity = Optional.For(NewIdentity());
			return DefaultInstance.WithFactory(
				triviaList: Optional.For(triviaList),
				fullStartPosition: Optional.For(fullStartPosition),
				startPosition: Optional.For(startPosition),
				length: Optional.For(length),
				value: Optional.For(value.GetValueOrDefault(DefaultInstance.Value)),
				identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
	
		public System.String Value {
			get { return this.value; }
		}
		
		/// <summary>Replaces the elements of the TriviaList collection with the specified collection.</summary>
		public new KeyValue WithTriviaList(params Trivia[] values) {
			return (KeyValue)base.WithTriviaList(values);
		}
		
		/// <summary>Replaces the elements of the TriviaList collection with the specified collection.</summary>
		public new KeyValue WithTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (KeyValue)base.WithTriviaList(values);
		}
		
		/// <summary>Adds the specified elements from the TriviaList collection.</summary>
		public new KeyValue AddTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (KeyValue)base.AddTriviaList(values);
		}
		
		/// <summary>Adds the specified elements from the TriviaList collection.</summary>
		public new KeyValue AddTriviaList(params Trivia[] values) {
			return (KeyValue)base.AddTriviaList(values);
		}
		
		/// <summary>Adds the specified element from the TriviaList collection.</summary>
		public new KeyValue AddTriviaList(Trivia value) {
			return (KeyValue)base.AddTriviaList(value);
		}
		
		/// <summary>Removes the specified elements from the TriviaList collection.</summary>
		public new KeyValue RemoveTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (KeyValue)base.RemoveTriviaList(values);
		}
		
		/// <summary>Removes the specified elements from the TriviaList collection.</summary>
		public new KeyValue RemoveTriviaList(params Trivia[] values) {
			return (KeyValue)base.RemoveTriviaList(values);
		}
		
		/// <summary>Removes the specified element from the TriviaList collection.</summary>
		public new KeyValue RemoveTriviaList(Trivia value) {
			return (KeyValue)base.RemoveTriviaList(value);
		}
		
		/// <summary>Clears all elements from the TriviaList collection.</summary>
		public new KeyValue RemoveTriviaList() {
			return (KeyValue)base.RemoveTriviaList();
		}
		
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected override SyntaxNode WithCore(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>)) {
			return this.WithFactory(
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public KeyValue With(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.String> value = default(ImmutableObjectGraph.Optional<System.String>)) {
			return (KeyValue)this.WithCore(
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length,
				value: value);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected virtual KeyValue WithCore(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.String> value = default(ImmutableObjectGraph.Optional<System.String>)) {
			var identity = default(ImmutableObjectGraph.Optional<System.UInt32>);
			return this.WithFactory(
				triviaList: Optional.For(triviaList.GetValueOrDefault(this.TriviaList)),
				fullStartPosition: Optional.For(fullStartPosition.GetValueOrDefault(this.FullStartPosition)),
				startPosition: Optional.For(startPosition.GetValueOrDefault(this.StartPosition)),
				length: Optional.For(length.GetValueOrDefault(this.Length)),
				value: Optional.For(value.GetValueOrDefault(this.Value)),
				identity: Optional.For(identity.GetValueOrDefault(this.Identity)));
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		private KeyValue WithFactory(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.String> value = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (
				(identity.IsDefined && identity.Value != this.Identity) || 
				(triviaList.IsDefined && triviaList.Value != this.TriviaList) || 
				(fullStartPosition.IsDefined && fullStartPosition.Value != this.FullStartPosition) || 
				(startPosition.IsDefined && startPosition.Value != this.StartPosition) || 
				(length.IsDefined && length.Value != this.Length) || 
				(value.IsDefined && value.Value != this.Value)) {
				return new KeyValue(
					identity: identity.GetValueOrDefault(this.Identity),
					triviaList: triviaList.GetValueOrDefault(this.TriviaList),
					fullStartPosition: fullStartPosition.GetValueOrDefault(this.FullStartPosition),
					startPosition: startPosition.GetValueOrDefault(this.StartPosition),
					length: length.GetValueOrDefault(this.Length),
					value: value.GetValueOrDefault(this.Value));
			} else {
				return this;
			}
		}
	
		/// <summary>Normalizes and/or validates all properties on this object.</summary>
		/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
		partial void Validate();
	
		/// <summary>Provides defaults for fields.</summary>
		/// <param name="template">The struct to set default values on.</param>
		static partial void CreateDefaultTemplate(ref Template template);
	
		/// <summary>Returns a newly instantiated KeyValue whose fields are initialized with default values.</summary>
		private static KeyValue GetDefaultTemplate() {
			var template = new Template();
			CreateDefaultTemplate(ref template);
			return new KeyValue(
				default(System.UInt32),
				template.TriviaList,
				template.FullStartPosition,
				template.StartPosition,
				template.Length,
				template.Value,
				skipValidation: true);
		}
	
		/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
		private struct Template {
			internal System.Collections.Immutable.ImmutableList<Trivia> TriviaList { get; set; }
	
			internal System.Int32 FullStartPosition { get; set; }
	
			internal System.Int32 StartPosition { get; set; }
	
			internal System.Int32 Length { get; set; }
	
			internal System.String Value { get; set; }
		}
		
		protected override SyntaxNodeChangedProperties DiffProperties(SyntaxNode other) {
			var propertiesChanged = base.DiffProperties(other);
		
			var otherKeyValue = other as KeyValue;
			if (otherKeyValue != null) {
				if (this.Value != otherKeyValue.Value) {
					propertiesChanged |= SyntaxNodeChangedProperties.Value;
				}
			}
		
			return propertiesChanged;
		}
		
		internal static KeyValue CreateWithIdentity(
				System.Collections.Immutable.ImmutableList<Trivia> triviaList,
				System.Int32 fullStartPosition,
				System.Int32 startPosition,
				System.Int32 length,
				ImmutableObjectGraph.Optional<System.String> value = default(ImmutableObjectGraph.Optional<System.String>),
				ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (!identity.IsDefined) {
				identity = NewIdentity();
			}
		
			return DefaultInstance.WithFactory(
					triviaList: Optional.For(triviaList),
					fullStartPosition: Optional.For(fullStartPosition),
					startPosition: Optional.For(startPosition),
					length: Optional.For(length),
					value: Optional.For(value.GetValueOrDefault(DefaultInstance.Value)),
					identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
		
		public new Builder ToBuilder() {
			return new Builder(this);
		}
		
		public static new Builder CreateBuilder() {
			return new Builder(DefaultInstance);
		}
		
		public new partial class Builder : SyntaxNode.Builder {
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			private KeyValue immutable;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected System.String value;
		
			internal Builder(KeyValue immutable) : base(immutable) {
				this.immutable = immutable;
		
				this.value = immutable.Value;
			}
		
			public System.String Value {
				get {
					return this.value;
				}
		
				set {
					this.value = value;
				}
			}
		
			public new KeyValue ToImmutable() {
				var triviaList = this.triviaList.IsDefined ? (this.triviaList.Value != null ? this.triviaList.Value.ToImmutable() : null) : this.immutable.TriviaList;
				return this.immutable = this.immutable.With(
					ImmutableObjectGraph.Optional.For(triviaList),
					ImmutableObjectGraph.Optional.For(this.FullStartPosition),
					ImmutableObjectGraph.Optional.For(this.StartPosition),
					ImmutableObjectGraph.Optional.For(this.Length),
					ImmutableObjectGraph.Optional.For(this.Value));
			}
		}
	}
	
	public partial class Keyword : SyntaxNode {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private static readonly Keyword DefaultInstance = GetDefaultTemplate();
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.String value;
	
		/// <summary>Initializes a new instance of the Keyword class.</summary>
		protected Keyword(
			System.UInt32 identity,
			System.Collections.Immutable.ImmutableList<Trivia> triviaList,
			System.Int32 fullStartPosition,
			System.Int32 startPosition,
			System.Int32 length,
			System.String value,
			ImmutableObjectGraph.Optional<bool> skipValidation = default(ImmutableObjectGraph.Optional<bool>))
			: base(
				identity: identity,
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length)
		{
			this.value = value;
			if (!skipValidation.Value) {
				this.Validate();
			}
		}
	
		public static Keyword Create(
			System.Collections.Immutable.ImmutableList<Trivia> triviaList,
			System.Int32 fullStartPosition,
			System.Int32 startPosition,
			System.Int32 length,
			ImmutableObjectGraph.Optional<System.String> value = default(ImmutableObjectGraph.Optional<System.String>)) {
			var identity = Optional.For(NewIdentity());
			return DefaultInstance.WithFactory(
				triviaList: Optional.For(triviaList),
				fullStartPosition: Optional.For(fullStartPosition),
				startPosition: Optional.For(startPosition),
				length: Optional.For(length),
				value: Optional.For(value.GetValueOrDefault(DefaultInstance.Value)),
				identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
	
		public System.String Value {
			get { return this.value; }
		}
		
		/// <summary>Replaces the elements of the TriviaList collection with the specified collection.</summary>
		public new Keyword WithTriviaList(params Trivia[] values) {
			return (Keyword)base.WithTriviaList(values);
		}
		
		/// <summary>Replaces the elements of the TriviaList collection with the specified collection.</summary>
		public new Keyword WithTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (Keyword)base.WithTriviaList(values);
		}
		
		/// <summary>Adds the specified elements from the TriviaList collection.</summary>
		public new Keyword AddTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (Keyword)base.AddTriviaList(values);
		}
		
		/// <summary>Adds the specified elements from the TriviaList collection.</summary>
		public new Keyword AddTriviaList(params Trivia[] values) {
			return (Keyword)base.AddTriviaList(values);
		}
		
		/// <summary>Adds the specified element from the TriviaList collection.</summary>
		public new Keyword AddTriviaList(Trivia value) {
			return (Keyword)base.AddTriviaList(value);
		}
		
		/// <summary>Removes the specified elements from the TriviaList collection.</summary>
		public new Keyword RemoveTriviaList(System.Collections.Generic.IEnumerable<Trivia> values) {
			return (Keyword)base.RemoveTriviaList(values);
		}
		
		/// <summary>Removes the specified elements from the TriviaList collection.</summary>
		public new Keyword RemoveTriviaList(params Trivia[] values) {
			return (Keyword)base.RemoveTriviaList(values);
		}
		
		/// <summary>Removes the specified element from the TriviaList collection.</summary>
		public new Keyword RemoveTriviaList(Trivia value) {
			return (Keyword)base.RemoveTriviaList(value);
		}
		
		/// <summary>Clears all elements from the TriviaList collection.</summary>
		public new Keyword RemoveTriviaList() {
			return (Keyword)base.RemoveTriviaList();
		}
		
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected override SyntaxNode WithCore(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>)) {
			return this.WithFactory(
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public Keyword With(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.String> value = default(ImmutableObjectGraph.Optional<System.String>)) {
			return (Keyword)this.WithCore(
				triviaList: triviaList,
				fullStartPosition: fullStartPosition,
				startPosition: startPosition,
				length: length,
				value: value);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		protected virtual Keyword WithCore(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.String> value = default(ImmutableObjectGraph.Optional<System.String>)) {
			var identity = default(ImmutableObjectGraph.Optional<System.UInt32>);
			return this.WithFactory(
				triviaList: Optional.For(triviaList.GetValueOrDefault(this.TriviaList)),
				fullStartPosition: Optional.For(fullStartPosition.GetValueOrDefault(this.FullStartPosition)),
				startPosition: Optional.For(startPosition.GetValueOrDefault(this.StartPosition)),
				length: Optional.For(length.GetValueOrDefault(this.Length)),
				value: Optional.For(value.GetValueOrDefault(this.Value)),
				identity: Optional.For(identity.GetValueOrDefault(this.Identity)));
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		private Keyword WithFactory(
			ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>> triviaList = default(ImmutableObjectGraph.Optional<System.Collections.Immutable.ImmutableList<Trivia>>),
			ImmutableObjectGraph.Optional<System.Int32> fullStartPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> startPosition = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.Int32> length = default(ImmutableObjectGraph.Optional<System.Int32>),
			ImmutableObjectGraph.Optional<System.String> value = default(ImmutableObjectGraph.Optional<System.String>),
			ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (
				(identity.IsDefined && identity.Value != this.Identity) || 
				(triviaList.IsDefined && triviaList.Value != this.TriviaList) || 
				(fullStartPosition.IsDefined && fullStartPosition.Value != this.FullStartPosition) || 
				(startPosition.IsDefined && startPosition.Value != this.StartPosition) || 
				(length.IsDefined && length.Value != this.Length) || 
				(value.IsDefined && value.Value != this.Value)) {
				return new Keyword(
					identity: identity.GetValueOrDefault(this.Identity),
					triviaList: triviaList.GetValueOrDefault(this.TriviaList),
					fullStartPosition: fullStartPosition.GetValueOrDefault(this.FullStartPosition),
					startPosition: startPosition.GetValueOrDefault(this.StartPosition),
					length: length.GetValueOrDefault(this.Length),
					value: value.GetValueOrDefault(this.Value));
			} else {
				return this;
			}
		}
	
		/// <summary>Normalizes and/or validates all properties on this object.</summary>
		/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
		partial void Validate();
	
		/// <summary>Provides defaults for fields.</summary>
		/// <param name="template">The struct to set default values on.</param>
		static partial void CreateDefaultTemplate(ref Template template);
	
		/// <summary>Returns a newly instantiated Keyword whose fields are initialized with default values.</summary>
		private static Keyword GetDefaultTemplate() {
			var template = new Template();
			CreateDefaultTemplate(ref template);
			return new Keyword(
				default(System.UInt32),
				template.TriviaList,
				template.FullStartPosition,
				template.StartPosition,
				template.Length,
				template.Value,
				skipValidation: true);
		}
	
		/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
		private struct Template {
			internal System.Collections.Immutable.ImmutableList<Trivia> TriviaList { get; set; }
	
			internal System.Int32 FullStartPosition { get; set; }
	
			internal System.Int32 StartPosition { get; set; }
	
			internal System.Int32 Length { get; set; }
	
			internal System.String Value { get; set; }
		}
		
		protected override SyntaxNodeChangedProperties DiffProperties(SyntaxNode other) {
			var propertiesChanged = base.DiffProperties(other);
		
			var otherKeyword = other as Keyword;
			if (otherKeyword != null) {
				if (this.Value != otherKeyword.Value) {
					propertiesChanged |= SyntaxNodeChangedProperties.Value;
				}
			}
		
			return propertiesChanged;
		}
		
		internal static Keyword CreateWithIdentity(
				System.Collections.Immutable.ImmutableList<Trivia> triviaList,
				System.Int32 fullStartPosition,
				System.Int32 startPosition,
				System.Int32 length,
				ImmutableObjectGraph.Optional<System.String> value = default(ImmutableObjectGraph.Optional<System.String>),
				ImmutableObjectGraph.Optional<System.UInt32> identity = default(ImmutableObjectGraph.Optional<System.UInt32>)) {
			if (!identity.IsDefined) {
				identity = NewIdentity();
			}
		
			return DefaultInstance.WithFactory(
					triviaList: Optional.For(triviaList),
					fullStartPosition: Optional.For(fullStartPosition),
					startPosition: Optional.For(startPosition),
					length: Optional.For(length),
					value: Optional.For(value.GetValueOrDefault(DefaultInstance.Value)),
					identity: Optional.For(identity.GetValueOrDefault(DefaultInstance.Identity)));
		}
		
		public new Builder ToBuilder() {
			return new Builder(this);
		}
		
		public static new Builder CreateBuilder() {
			return new Builder(DefaultInstance);
		}
		
		public new partial class Builder : SyntaxNode.Builder {
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			private Keyword immutable;
		
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			protected System.String value;
		
			internal Builder(Keyword immutable) : base(immutable) {
				this.immutable = immutable;
		
				this.value = immutable.Value;
			}
		
			public System.String Value {
				get {
					return this.value;
				}
		
				set {
					this.value = value;
				}
			}
		
			public new Keyword ToImmutable() {
				var triviaList = this.triviaList.IsDefined ? (this.triviaList.Value != null ? this.triviaList.Value.ToImmutable() : null) : this.immutable.TriviaList;
				return this.immutable = this.immutable.With(
					ImmutableObjectGraph.Optional.For(triviaList),
					ImmutableObjectGraph.Optional.For(this.FullStartPosition),
					ImmutableObjectGraph.Optional.For(this.StartPosition),
					ImmutableObjectGraph.Optional.For(this.Length),
					ImmutableObjectGraph.Optional.For(this.Value));
			}
		}
	}
}


